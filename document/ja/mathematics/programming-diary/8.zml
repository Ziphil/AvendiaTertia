\zml?|version="1.1"|;
\xml?|version="1.0",encoding="UTF-8"|;


\page<
  \name<ARC091-F: グランディ数>
  \use-math;

  \h1<日記 (2018 年 3 月 13 日)>
  \p<
    一昨日の話ですが ARC091 に出てきました。
    結果は、3 問正解 1400 点で 834 人中 226 位でした。
    レートは 1198 (緑) に増加しました。
    もうこれ水色ってことで良くない?
  >
  \p<
    さて、ARC091 の F 問題について簡単にまとめておきます。
    本番では時間がなくて考えることもできず、終わった後に考えても解き方が分からず、解説を見たら知らないテクニックが使われていました。
    問題は\ae|href="https://beta.atcoder.jp/contests/arc091/tasks/arc091_d"|<こちら>です。
  >
  \p<
    場の状態を交互に変化させていくゲームがあって、状態をこれ以上遷移できなくなったら負けとします。
    これを両者が最善を尽くしてプレイするときに、どちらが勝つか判定する問題です。
    これを判定する最も愚直な方法は以下のようなものでしょう。
    それぞれの場の状態 &m<P> に対し、win もしくは lose の値をとる &m<w (P)> を以下のように定めます。
  >
  \ul<
    \li<&m<P> から状態の遷移ができない場合は &m<w (P) = \rm<lose>>>
    \li<&m<P> から遷移できる状態 &m<Q> で &m<w (Q) = \rm<lose>> なるものが存在すれば &m<w (P) = \rm<win>>>  
    \li<&m<P> から遷移できる状態 &m<Q> が全て &m<w (Q) = \rm<win>> なるならば &m<w (P) = \rm<lose>>>
  >
  \p<
    これによって初期状態 &m<\sb<P><0>> に対する &m<w (\sb<P><0>)> を求めて、それが win なら先手の勝ちで lose なら後手の勝ちとなります。
  >
  \p<
    この方法は分かりやすいですが、計算量が大きいので複雑なゲームには向きません。
    そこで、それぞれ状態 &m<P> に対し、今度は以下のように定まる非負整数 &m<g (P)> を考えてみます。
  >
  \ul<
    \li<&m<P> から状態の遷移ができない場合は &m<g (P) = 0>>
    \li<上記以外の &m<P> に対する &m<g (P)> は集合 &m<`{ g (Q) \mid; Q \text< は > P \text< から遷移できる状態> `}> に属さない最小の非負整数>
  >
  \p<
    すると、初期状態 &m<\sb<P><0>> に対する &m<g (\sb<P><0>)> を求めて、それが 0 以外なら先手の勝ちで 0 なら後手の勝ちとなります。
    実際、少し考えれば &m<w (P)> を求めるのも &m<g (P)> を求めるのも同じことだと分かるので、これは当たり前です。
    ちなみに、この &m<g (P)> は「&m<P> のグランディ数」と呼ばれます。
  >
  \p<
    さて、これだけでは実質最初のアルゴリズムと何も変わってないので、グランディ数の良さは分かりません。
    グランディ数は、ゲームがたくさんある場合に真価を発揮します。
    状態を遷移させるゲームが独立に複数個あり、各プレイヤーは毎ターンにどれか 1 つのゲームを選んでその状態を遷移させることを考えましょう。
    全てのゲームで状態遷移ができなくなったら負けです。
    この場合にどちらのプレイヤーが勝つかは、各ゲームの初期状態でのグランディ数を独立に求め、それらのビット排他的論理和を計算することで判定できてしまいます。
    すごくない?
  >
  \p<
    ということで、今回の問題では、それぞれの山に対してグランディ数を求めれば良いことになります。
    整数 &m<K> が定まっている山に石が &m<A> 個ある場合のグランディ数を &m<g (A, K)> と書くことにしましょう。
    上に書いた導出方法の通りに愚直に計算すると計算量が大きくてダメなので、少し考える必要があります。
    実際に少し考えると、以下のことが分かります。
  >
  \ul<
    \li<非負整数 &m<q> に対して &m<g (qK, K) = q>>
    \li<非負整数 &m<q> と整数 &m<r \srel; (0 `< r `< q)> に対して &m<g (qK + r, K) = g (qK + r - q - 1, K)>>
  >
  \p<
    ただ、この通りに実装すると微妙に TLE します。
    これを回避するため、上の箇条書きの 2 番目の項目の漸化式において &m<q + 1> をひくわけですが、&m<q> が変わらないうちは一気にひいてしまうことにします。
    これで全てのテストケースに通るようになります。
  >
  \p<
    ということで、以下がうまくいくプログラムです。
  >
  \pre~*<
    public void run() {
      BetterScanner scanner = new BetterScanner(System.in);

      int n = scanner.nextInt();

      int result = 0;
      for (int i = 0 ; i `< n ; i ++) {
        int a = scanner.nextInt();
        int k = scanner.nextInt();
        result ^= grundy(a, k);
      }
      if (result == 0) {
        System.out.println("Aoki");
      } else {
        System.out.println("Takahashi");
      }
    }

    public int grundy(int a, int k) {
      while (true) {
        int q = a / k;
        int r = a % k;
        if (r == 0) {
          return q;
        }
        // q が変化しなくなるまでの分を一気にひいてループ回数を減らす
        a -= (q + 1) * ((r - 1) / (q + 1) + 1);
      }
    }
  >
  \p<
    グランディ数を効率的に求める方法はたぶんその都度考えないといけないので、まあ、がんばろう。
  >

>