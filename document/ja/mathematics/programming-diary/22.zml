\zml?|version="1.1"|;
\xml?|version="1.0",encoding="UTF-8"|;


\page<
  \name<代数と余代数と何とか morphism>
  \use-math|prefix="1"|;

  \h1<日記 (2019 年 11 月 16 日)>
  \p<
    Haskell を勉強していると、ちょくちょく catamorphism とか anamorphism のようなギリシャ語の接頭辞が付いた morphism を見かける。
    これらの概念についてそろそろちゃんと理解したくなってきたので、分かったことをまとめようと思う。
    ちなみに、私は圏論が好きなので、プログラミング言語論的な視点よりも圏論的な視点の方を優先する。
  >
  \p<
    この日記の読者層はよく分からないが、圏論について詳しくないのであれば、圏とは集合全体を集めたものだと思い、関手とは集合に対して別の集合を対応付けるような規則だと思って構わない。
    さらに、圏の対象を集合と読み替え、圏の射は写像と読み替えて良い。
  >
  \p<
    本題に入る。
    問題となっている射を理解するには、まず自己関手上の代数について知っておく必要がある。
    これは、以下で定義される概念である。
  >
  \thm|type="def"|<
    \p<
      圏 &m<\scr<C>> 上の自己関手 &m<F: \scr<C> \to; \scr<C>> をとる。
      &m<\scr<C>> の対象 &m<A> と射 &m<`a: FA \to; A> の組 &m<(A, `a)> を &m<F>-\def<代数\fl<algebra>> という。
    >
  >
  \thm|type="def"|<
    \p<
      圏 &m<\scr<C>> 上の自己関手 &m<F: \scr<C> \to; \scr<C>> をとる。
      &m<F>-代数 &m<(A, `a), (B, `b)> に対し、&m<\scr<C>> の射 &m<f: A \to; B> が、図式
      &mb<
        \diag<
          \v<FA> \v<FB> \br;
          \v<A> \v<B>
          \ar|s="1",e="2"|<Ff> \ar|s="1",e="3",inv|<`a>
          \ar|s="3",e="4",inv|<f> \ar|s="2",e="4"|<`b>
        >
      >
      を可換にするとき、&m<f> を &m<F>-\def<代数の射\fl<algebra morphism>> という。
    >
  >
  \p<
    上記の定義において、&m<F>-代数とその間の射は圏を成す。
    この圏は、以降 &m<\sb<\bfrm<Alg>><F> (\scr<C>)> で表すことにする。
  >
  \p<
    代数の中で特に重要なのが、以下で定義される始代数である。
    これは、プログラミングで用いられる様々なデータ構造を表現することができるものである。
  >
  \thm|type="def"|<
    \p<
      圏 &m<\scr<C>> 上の自己関手 &m<F: \scr<C> \to; \scr<C>> をとる。
      ある &m<F>-代数 &m<(S, `s)> を考えるとき、任意の &m<F>-代数 &m<(A, `a)> に対して、&m<F>-代数の射 &m<f: (S, `s) \to; (A, `a)> が一意に存在するとする。
      このとき、&m<(S, `s)> を &m<F>-\def<始代数\fl<initial algebra>> という。
    >
  >
  \p<
    定義から分かるように、&m<F>-始代数とは単に &m<\sb<\bfrm<Alg>><F> (\scr<C>)> の始対象のことである。
  >
  \p<
    さて、以上の準備のもと、最初の疑問だった catamorphism が定義できる。
    ここだけ英単語になるのも少し気持ち悪いので、勝手に日本語訳を当てることにする。
  >
  \thm|type="def"|<
    \p<
      圏 &m<\scr<C>> 上の自己関手 &m<F: \scr<C> \to; \scr<C>> をとる。
      &m<F>-代数 &m<(A, `a)> に対し、&m<F>-始代数 &m<(S, `s)> からの唯一の射 &m<f: (S, `s) \to; (A, `a)> を、&m<(A, `a)> による \def<下方射\fl<catamorphism>> と呼んで &m<\rm<cata> (A, `a)> で表す。
    >
  >
  \p<
    イメージを掴むため、1 つ例を挙げておこう。
    圏として &m<\bfrm<Set>> を考え、ある集合 &m<V> を固定し、
    &mb<
      \array|align="rrcl"|<
        \c<\sb<F><V>:> \c<\bfrm<Set>> \c<\longto;> \c<\bfrm<Set>> \br;
        \c; \c<A> \c<\longmapsto;> \c<1 + V \times; A>
      >
    >
    とおく。
    すると、&m<\sb<F><V>>-代数とは、集合 &m<A> と写像 &m<`a: 1 + V \times; A \to; A> の組 &m<(A, `a)> である。
    ここで、余積の普遍性によって、写像 &m<`a> は 2 つの写像 &m<\sb<`a><0>: 1 \to; A>, &m<\sb<`a><\rm<c>>: V \times; A \to; A> の組と同一視できる。
    さらに、写像 &m<\sb<`a><0>> は &m<A> の元 &m<\sb<a><0> \in; A> と同一視できる。
    以上のことから、&m<\sb<F><V>>-代数とは、集合 &m<A> とその元 &m<\sb<a><0> \in; A> と写像 &m<\sb<`a><\rm<c>>: V \times; A \to; A> の組 &m<(A, \sb<a><0>, \sb<`a><\rm<c>>)> とも思うことができる。
  >
  \p<
    さて、それでは &m<\sb<F><V>>-始代数とはどのようなものだろうか。
    これは実は &m<V> の元から成る有限リスト全体の集合になる。
    すなわち、
    &mb<
      S \coloneqq; `{ \langle; \sb<v><1>, \cdots;, \sb<v><n> \rangle; \mid; \sb<v><i> \in; V, n \geq; 0 `}
    >
    とおき、&m<\sb<s><0>> を 0 個の元から成るリスト &m<\langle; \rangle;> とし、&m<\sb<`s><\rm<c>>> はリストへの値の追加
    &mb<
      \array|align="rrcl"|<
        \c<\sb<`s><\rm<c>>:> \c<V \times; S> \c<\longto;> \c<S> \br;
        \c; \c<(v, \langle; \sb<v><1>, \cdots;, \sb<v><n> \rangle;)> \c<\longmapsto;> \c<\langle; v, \sb<v><1>, \cdots;, \sb<v><n> \rangle;>
      >
    >
    であるとすると、&m<(S, \sb<s><0>, \sb<`s><\rm<c>>)> は &m<\sb<F><V>>-始代数になる。
    実際、別の &m<\sb<F><V>>-始代数 &m<(A, \sb<a><0>, \sb<`a><\rm<c>>)> があったとすると、写像 &m<f: S \to; A> を帰納的に
    &mb<
      \array|align="rcl"|<
        \c<f (\langle; \rangle;)> \c<\coloneqq;> \c<\sb<a><0>> \br;
        \c<f (\langle; \sb<v><1>, \cdots;, \sb<v><n> \rangle;)> \c<\coloneqq;> \c<\sb<`a><\rm<c>> (\sb<v><1>, f (\langle; \sb<v><2>, \cdots;, \sb<v><n> \rangle;))>
      >
    >
    と定めれば、&m<f> は &m<\sb<F><V>>-代数の唯一の射となることが分かる。
    すなわち、&m<f = \rm<cata> (A, \sb<a><0>, \sb<`a><\rm<c>>)> である。
  >
  \p<
    &m<\sb<F><V>>-始代数についてもう少し詳しく見てみよう。
    これは、いわば &m<\sb<F><V>> が定める構造に関して、次のような意味で「自由に」生成されたデータ構造であると見なすことができる。
    &m<\sb<F><V>>-代数とは、集合 &m<A> の他に元 &m<\sb<a><0> \in; A> と写像 &m<\sb<`a><\rm<c>>: V \times; A \to; A> が定まっているものであった。
    ここで、&m<A> がどのような集合であるか全く知らない状態から、&m<A> の元を得るにはどうしたら良いかを考えてみる。
    まず、&m<\sb<a><0>> という元はすでに定まっているので、&m<A> の元として &m<\sb<a><0>> が得られた。
    次に、写像 &m<\sb<`a><\rm<c>>: V \times; A \to; A> があるので、&m<V> の元 &m<\sb<v><1>> があれば、先程得られた &m<\sb<a><0>> と組み合わせて、&m<\sb<`a><\rm<c>> (\sb<v><1>, \sb<a><0>)> という新しい &m<A> の元が得られる。
    すると、さらに &m<V> の元 &m<\sb<v><2>> があれば、ここから &m<\sb<`a><\rm<c>> (\sb<v><2>, \sb<`a><\rm<c>> (\sb<v><1>, \sb<a><0>))> というまた新しい &m<A> の元が得られ、以降これを続けることで次々と &m<A> の元が得られる。
    このようにして再帰的に得られるものだけをそれぞれ区別しつつ集めた集合が、まさに &m<\sb<F><V>>-代数 &m<S> である。
    すなわち、始代数というのは、自己関手が定める構造だけを使って再帰的に (同じ意味だが帰納的に) 得られる元を区別しつつ集めたものと捉えられる。
  >
  \p<
    次に、&m<\sb<F><V>>-代数の下方射について詳しく見てみる。
    繰り返すが、&m<\sb<F><V>>-代数の構成要素は、集合 &m<A> とその元 &m<\sb<a><0> \in; A> と写像 &m<\sb<`a><\rm<c>>: V \times; A \to; A> であった。
    これはまさに、リストの畳み込みを行う関数 (Haskell では \m<foldr>, Ruby では \m<inject>) に渡す引数である。
    そして、上の定義を見ると分かるように、&m<\rm<cata> (A, \sb<a><0>, \sb<`a><\rm<c>>)> がまさにその畳み込み関数になっている。
    すなわち、代数の下方射とは、代数によって再帰的に定められたデータ構造に対して畳み込みを行うような関数を表現していると捉えられる。
  >
  \p<
    さて、今度は代数の双対概念である余代数と終余代数を考える。
    単に圏論的双対をとるだけだが、念のため定義を書き下しておく。
  >
  \thm|type="def"|<
    \p<
      圏 &m<\scr<C>> 上の自己関手 &m<F: \scr<C> \to; \scr<C>> をとる。
      &m<\scr<C>> の対象 &m<C> と射 &m<`g: C \to; FC> の組 &m<(C, `g)> を &m<F>-\def<余代数\fl<coalgebra>> という。
    >
  >
  \thm|type="def"|<
    \p<
      圏 &m<\scr<C>> 上の自己関手 &m<F: \scr<C> \to; \scr<C>> をとる。
      &m<F>-余代数 &m<(C, `g), (D, `d)> に対し、&m<\scr<C>> の射 &m<h: C \to; D> が、図式
      &mb<
        \diag<
          \v<C> \v<D> \br;
          \v<FC> \v<FD>
          \ar|s="1",e="2"|<h> \ar|s="1",e="3",inv|<`g>
          \ar|s="3",e="4",inv|<Fh> \ar|s="2",e="4"|<`d>
        >
      >
      を可換にするとき、&m<h> を &m<F>-\def<余代数の射\fl<coalgebra morphism>> という。
    >
  >
  \thm|type="def"|<
    \p<
      圏 &m<\scr<C>> 上の自己関手 &m<F: \scr<C> \to; \scr<C>> をとる。
      ある &m<F>-余代数 &m<(T, `t)> を考えるとき、任意の &m<F>-余代数 &m<(C, `g)> に対して、&m<F>-余代数の射 &m<h: (C, `g) \to; (T, `t)> が一意に存在するとする。
      このとき、&m<(T, `t)> を &m<F>-\def<終余代数\fl<terminal coalgebra>> という。
    >
  >
  \thm|type="def"|<
    \p<
      圏 &m<\scr<C>> 上の自己関手 &m<F: \scr<C> \to; \scr<C>> をとる。
      &m<F>-余代数 &m<(C, `g)> に対し、&m<F>-終余代数 &m<(T, `t)> への唯一の射 &m<h: (C, `g) \to; (T, `t)> を、&m<(C, `g)> による \def<上方射\fl<anamorphism>> と呼んで &m<\rm<ana> (C, `g)> で表す。
    >
  >
  \p<
    &m<F>-余代数とその間の射が成す圏は、以降 &m<\sb<\bfrm<Coalg>><F> (\scr<C>)> で表すことにする。
  >
  \p<
    例として、先程挙げた &m<\sb<F><V>> を再び考える。
    &m<\sb<F><V>>-余代数とは、集合 &m<C> と写像 &m<`g: C \to; 1 + V \times; C> の組 &m<(C, `g)> である。
    この写像 &m<`g> は、各元 &m<c \in; C> に対して、特殊なケースとして 1 の唯一の元を対応させるか、そうでなければ &m<V> と &m<C> の元の組 &m<(v, c')> を対応させるものである。
  >
  \p<
    &m<\sb<F><V>>-終余代数は、&m<V> の元から成る有限もしくは無限リスト (リストよりストリームと言った方が正確かもしれない) 全体の集合になる。
    つまり、
    &mb<
      T \coloneqq; `{ \langle; \sb<v><1>, \sb<v><2>, \cdots; \rangle; \mid; \sb<v><i> \in; V, \sb<v><i> \text< たちは有限個でも無限個でも良い> `}
    >
    とおき、1 の唯一の元を &m<\star;> で表すことにして、&m<`t> はリストの先頭と残りを取り出す操作
    &mb<
      &mark<\wheart;>
      \array|align="rrcl"|<
        \c<`t:> \c<T> \c<\longto;> \c<1 + V \times; T> \br;
        \c; \c<\langle; \sb<v><1>, \sb<v><2>, \cdots; \rangle;> \c<\longmapsto;> \c<\case<
          \c<\star;> \c<(\text<リストが空のとき>)> \br;
          \c<(\sb<v><1>, \langle; \sb<v><2>, \cdots; \rangle;)> \c<(\text<リストが空でないとき>)>
        >>
      >
    >
    であるとすると、&m<(T, `t)> は &m<\sb<F><V>>-終余代数になる。
    実際、別の &m<\sb<F><V>>-余代数 &m<(C, `g)> があったとすると、写像 &m<h: C \to; T> であって、
    &mb<
      h (c) = \case<
        \c<\langle; \rangle;> \c<(`g (c) = \star|ord|;)> \br;
        \c<\langle; v, h (c') \rangle;> \c<(`g (c) \eqqcolon; (v, c'))>
      >  
    >
    を満たすものが作れ、これが &m<\sb<F><V>>-余代数の唯一の射となることが分かる。
    すなわち、&m<h = \rm<ana> (C, `g)> である。
  >
  \p<
    &m<\sb<F><V>>-終余代数について詳しく見よう。
    &m<\sb<F><V>>-余代数とは、集合 &m<C> の他に写像 &m<`g: C \to; 1 + V \times; C> が定まっているものであった。
    この写像によって、ある &m<C> の元 &m<c> があると、&m<`g> によって &m<\star;> が返ってこない限りは、&m<V> の元 &m<\sb<v><1>> と新たな &m<C> の元 &m<\sb<c><1>> が得られる。 
    この &m<c'> を使えば、再び &m<\star;> が返ってこない限りは、さらに &m<V> の元 &m<\sb<v><2>> と新たな &m<C> の元 &m<\sb<c><2>> が得られ、この操作は (もしかしたら無限に) 続けることができる。
    この操作を行うごとに毎回 &m<V> の元が得られるので、これらのデータを使ってまた別の計算をすることができる。
    つまり、代数を考えるときは &m<\sb<F><V>> は代数の元の「作り方」を定めていたのに対し、余代数を考えるときは &m<\sb<F><V>> は余代数の元の「使い方」を定めていると捉えることができる。
    この捉え方をすれば、終余代数というのは、自己関手によって定まる元の使い方が保証されるようにできるだけ元を集めたものと見なすことができる。
  >
  \p<
    ということで、&m<\sb<F><V>> は余代数の元の使い方を定めていると思えるわけだが、余代数に定まる射 &m<`g> が、まさにこの使い方に沿って実際に元を使えるようにしているものである。
    実際、上の式 &m<\wheart;> を見ると、リストが空かどうかで場合分けし、空でなければ先頭の元と残りのリストに分割しているわけだが、これは Haskell などにおけるリストのパターンマッチと全く同じ形である。
    すなわち、余代数の射はパターンマッチさせる関数と見なせるのである。
  >
  \p<
    次に、&m<\sb<F><V>>-余代数の上方射について見る。
    すでに述べたように、&m<\sb<F><V>>-余代数があると、そこに定まっている射 &m<`g> を繰り返し使うことで、データを次々と取り出すことができる。
    このように取り出したデータを順に集めて (無限長かもしれない) 列にするのが &m<\rm<ana> (C ,`g)> である。
    Haskell には \m<unfoldr> という名前で全く同じ処理をする関数が用意されている。
    このことから、余代数の上方射は、その余代数が定めるデータを取り出す関数によって取り出されるものを順にデータ構造に収める役割をもつものであると捉えられる。
  >
  \p<
    以上、下方射と上方射の定義と気持ちをまとめてみた。
    次回があれば、リスト以外の具体例や Haskell における実装なども勉強してまとめたいと思う。
  >

>