\zml?|version="1.1"|;
\xml?|version="1.0",encoding="UTF-8"|;


\page<
  \name<\m<Monad> と \m<Applicative> の違い>

  \h1<日記 (2019 年 3 月 11 日)>
  \p<
    \m<Functor> は関手だし \m<Monad> は文脈付きの値を扱う構造ということで、この 2 つは何となく気持ちが掴めてきたんですが、その間にある \m<Applicative> の気持ちがよく分かりませんでした。
    すると、\ae|href="https://twitter.com/hsjoihs/status/1104339295584759808"|<Twitter> で hsjoihs さんから「前の結果に依存して計算を変えるという \m<Monad> の機能を取り除いたのが \m<Applicative>」という捉え方があると教えてもらいました。
    これを聞いたときは分かったような分からないようなという感じでしたが、だんだん分かってきたのでまとめてみます。
  >
  \p<
    \m<Monad> には do 構文という専用のシンタックスシュガーがあって、あたかも手続き型かのように処理を書くことができます。
    例えば、以下のような関数を作ることができます。
    \m<f> と \m<g> があるモナド \m<m> 上のアクションで、\m<h> は普通の関数です。
  >
  \pre~*<
    mofu x = do
      y <- f x
      z <- g x y  -- !!
      return $ h y z
  >
  \p<
    これは以下のような式に脱糖されます。
    \m<Monad> クラスで定義されている \m<`>`>=> が使われていますね。
    分かりやすいように括弧を書いていますが、結合性の仕様から実際は不要です。
  >
  \pre~*<
    mofu x = f x `>`>= (\y -`> g x y `>`>= (\z -`> return $ h y z))
  >
  \p<
    ここで注目すべきは、最初の do 構文を使った表現の 3 行目において、\m<z> が \m<y> に依存しているところです。
    \m<y> というのはその前の計算 (\m<f> の実行) で得られた値なので、まさに前の結果に依存して計算が変わっているわけです。
  >
  \p<
    仮に \m<g> が第 2 引数を取らず、\m<z> の計算のとき \m<y> に依存していなかったらどうでしょうか。
    つまり、以下のような処理を考えるわけです。
  >
  \pre~*<
    mofu x = do
      y <- f x
      z <- g x  -- y に依存させない
      return $ h y z
  >
  \p<
    これも、同じように以下のように脱糖されます。
  >
  \pre~*<
    mofu x = f x `>`>= (\y -`> g x `>`>= (\z -`> return $ h y z))
  >
  \p<
    しかし、これは以下の式と等価です。
  >
  \pre~*<
    mofu x = h <$`> f x <*`> g x
  >
  \p<
    \m~<<$`>> は \m<Functor> クラスで定義されていて、\m~<<*`>> は \m<Applicative> クラスで定義されているので、上の式を書く分には \m<m> が \m<Monad> のインスタンスである必要はなく、\m<Applicative> のインスタンスで十分です。
  >
  \p<
    つまり、アクションを実行した結果として何らかの値を取り出すときに、アクションの引数として前の実行結果の値を使っていなければ、\m<`>`>=> を使わずに \m~<<$`>> と \m~<<*`>> だけで済ませられるわけです。
    これが、「前の結果に依存して計算を変えるという \m<Monad> の機能を取り除いたのが \m<Applicative>」という言明の正体です。
  >
  \p<
    これは、各演算子のシグネチャを見ることでも分かります。
  >
  \pre~*<
    (<$`>) :: Functor f =`> (a -`> b) -`> f a -`> f b
    (<*`>) :: Applicative f =`> f (a -`> b) -`> f a -`> f b
    (`>`>=) :: Monad m =`> m a -`> (a -`> m b) -`> m b
  >
  \p<
    \m<`>`>=> は、第 1 引数として受け取るのは \m<m a> 型の値なのに、第 2 引数で受け取る変数の始域は \m<a> です。
    こうなっているおかげで、文脈付きの値である \m<m a> 型の値が、あたかも普通の \m<a> 型の値であるかのように関数に渡し、その結果を得ることができるわけです。
    しかし、\m~<<$`>> と \m~<<*`>> ではどちらも、このような文脈付きの値を普通の値として渡せるという状況は起きていません。
    そのため、この 2 つだけでは以前のアクションの結果を次のアクションに渡すことはできず、前の文脈に応じて実行内容を変えることはできないのです。
  >

>