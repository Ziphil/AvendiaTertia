\zml?|version="1.1"|;
\xml?|version="1.0",encoding="UTF-8"|;


\page<
  \name<範囲と数値が混ざった配列>

  \h1<日記 (2014 年 9 月 30 日)>
  \p<
    だんだんとマップで使うブロックの種類が増えてきて、どのブロックがどのような種類なのか指定しないといけなくなりました。
    例えば、通行不可能なブロックはどれで、下から上へのみ通行できるブロックはどれで、みたいな感じです。
    で、普通に、配列にまとめて、その配列に含まれているかどうかでブロックの種類を判定します。
  >
  \pre~*<
    walls = [1, 2, 3, 4, 5, 10, 11, 12, 15, 18, 19, 23, 27, 28, 29, 30, 31, 32]
    id = 29
    p walls.include?(id)  #=`> true
  >
  \p<
    \k<…>面倒なわけです。
    特に連番が。
    Ruby には \m<Range> インスタンスのリテラルがあるわけですから、これを使いたいのです。
  >
  \pre~*<
    walls = [1..5, 10..12, 15, 18, 19, 23, 27..32]
    id = 29
    p walls.include?(id)  #=`> false
  >
  \p<
    しかし、もちろんこれではダメです。
    \m<walls> という変数に 29 という値そのものが含まれていないからです。
    ここで諦めたら試合終了なので、\m<Range> インスタンスか \m<Integer> インスタンスかで場合分けしてみます。
  >
  \pre~*<
    walls = [1..5, 10..12, 15, 18, 19, 23, 27..32]
    id = 29
    p walls.any?{|s| (s.class == Range) ? s.include?(id) : s == id}  #=`> true
  >
  \p<
    はい、正常に動作します。
    やったね。
  >
  \p<
    しかし\k<…>。
    なんというか\k<…>。
    美しくない!
    \k<…>そう思ってしまったのです。
    場合分けなんて、そんなまどろっこしいことやってられませんよ。
    すると、思いついてしまったわけです。
  >
  \pre~*<
    walls = [1..5, 10..12, 15, 18, 19, 23, 27..32]
    id = 29
    p walls.any?{|s| s === id}  #=`> true
  >
  \p<
    こんなところで活躍するとは思ってませんでしたね。
  >

>