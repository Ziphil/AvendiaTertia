\zml?|version="1.1"|;
\xml?|version="1.0",encoding="UTF-8"|;


\page<
  \name<\m<Monad> と \m<ArrowApply> の同値性>

  \h1<日記 (2019 年 3 月 11 日)>
  \p<
    \a|href="17.html"|<3 月 11 日>では、ある意味でモナドを一般化したものも言える \m<Arrow> という型クラスについて扱いました。
    Haskell には、この \m<Arrow> にさらに構造を付け加えた型クラスがいくつか定義されています。
    ここでは、その 1 つである \m<ArrowApply> に触れたいと思います。
  >
  \p<
    まずは \m<Arrow> や計算からは離れて、具体的な関数の話から始めます。
    \m<a> 型から \m<b> 型への関数 (つまり \m<a -`> b> 型の値) \m<f> と \m<a> 型の値 \m<x> から成るタプルがあったとします。
    すると、\m<f> を \m<x> に適用することで、\m<b> 型の値を得ることができます。
    ここで行った「関数と値からそれらを適用した結果の値を得る」という操作も、また関数になります。
    具体的には、\m<(a -`> b, a) -`> b> 型をもちます。
  >
  \p<
    これを計算に一般化すると、\m<a> 型から \m<b> 型への計算と \m<a> 型の値が与えれたとき、それを実行した結果である \m<b> 型の値を得ることそのものもまた計算になる、と言えます。
    この計算と値から実行結果を得る計算は、考えている \m<Arrow> クラスのインスタンスを \m<h> と書くことにすれば、\m<h (h a b, a) b> と書くことができます。
    この構造を追加した \m<Arrow> クラスが \m<ArrowApply> クラスです。
  >
  \pre~*<
    class Arrow h =`> ArrowApply h where
      -- 計算と値から結果を得るという計算
      app :: h (h a b, a) b
  >
  \p<
    前回述べた通り、モナドはクライスリ圏を作ることで \m<Arrow> のインスタンスにできました。
    これはさらに \m<ArrowApply> のインスタンスにもなります。
    ただ関数適用するだけです。
  >
  \pre~*<
    instance Monad m =`> ArrowApply (Kleisli m) where
      -- 計算と値から結果を得るという計算
      app :: (a -`> m b, a) -`> m b
      app (f, x) = f x
  >
  \p<
    ということで、\m<Monad> のインスタンス \m<m> からは \m<ArrowApply> のインスタンス \m<Kleisli m> が作れるわけです。
    実はこれは逆方向もできて、\m<ArrowApply> のインスタンス \m<h> から \m<Monad> のインスタンスを作ることができます。
    これには \m<ArrowMonad h> という名前が付いています。
  >
  \pre~*<
    type ArrowMonad h b = h () b  -- () はユニット型
  >
  \p<
    実際、以下のように実装できます。
  >
  \pre~*<
    instance Arrow h =`> Monad (ArrowMonad h) where
      -- リターン
      return :: a -`> h () a
      return x = arr (const x)
      -- バインド
      (`>`>=) :: h () a -`> (a -`> h () b) -`> h () b
      s `>`>= f = s `>`>`> arr f' `>`>`> app
        where
          f' :: a -`> (h () b, ()) 
          f' x = (f x, ())
  >
  \p<
    \m<`>`>=> の定義の方が若干分かりづらいので、型に関して少し補足しておきます。
    まず、\m<s> は \m<h () a> 型の計算です。
    次に、where の中で \m<f'> を定義しているのですが、これは \m<a -`> (h () b, ())> 型の関数で、これを \m<arr> によって \m<h a (h () b, ())> 型の計算に変換しています。
    最後の \m<app> は、ここでは \m<h (h () b, ()) b> 型の計算として利用しています。
    \m<`>`>=> の定義ではこれら 3 つの計算を順に合成しているわけですが、合成の順に \m<h () a> 型, \m<h a (h () b, ())> 型, \m<h (h () b, ()) b> 型となっているので、正しく合成することができ、最終的に \m<h () b> 型の計算が得られます。
  >
  \p<
    ということで、細かい話を省略すれば、\m<Monad> と \m<ArrowApply> はほぼ同じ構造をもっているということになります。
    言い換えれば、\m<Monad> と \m<ArrowApply> はともに、計算の概念を関数としてどう定式化するかという問いに対して、それぞれ異なる視点を与えているということになるわけです。
  >
  \h1<追記 (2019 年 3 月 16 日)>
  \p<
    \m<Monad> と \m<ArrowApply> が等価であることを数学的に示す PDF を書き始めました。
    \a|href="../../file/mathematics/14.pdf"|<ここ>から見られます。
  >

>