\zml?|version="1.1"|;
\xml?|version="1.0",encoding="UTF-8"|;


\page<
  \name<イントロダクション>
  \use-math|prefix="1"|;

  \h1<日記 (2025 年 12 月 22 日)>
  \p<
    ふと思い立って計算可能性理論の基礎を勉強し始めたので、ここに勉強ノートとしてまとめていこうと思う。
    基本的に Enderton\mref|type="bib",ref="ectx"|; を参考にする。
  >
  \p<
    古くから数学者たちは数多くの命題を証明してきたが、それらはすべて人間の思考と直感による営みであった。
    そんな中 1928 年、David Hilbert と Wilhelm Ackermann は、「数学的命題の真偽を機械的な手順によって自動的に判定することは可能か」という問いを投げかけた。
    しかし、この問いに答えるには、そもそも「機械的に計算できる」とは数学的に何を意味するのかを厳密に定義する必要があった。
    こうして、「計算」の定義を巡る数学者たちの考察が始まった。
  >
  \p<
    最初に Kurt Gödel は、方程式系に基づいて式を変形することで値が導かれる「一般再帰関数」と呼ばれる関数のクラスを定義した。
    このような関数は単純な操作の繰り返しでその値を求めることができるため、これを「計算できる」関数と見なすのは自然だと考えられた。
    しかし、当時の Gödel 自身は、直感的に「計算できる」と思える関数がこれで全て網羅できているかという点については懐疑的だったようである。
    続いて Alonzo Church は、計算を関数の適用と抽象化のプロセスと捉え、「ラムダ計算」という体系を構築した。
    しかし、この体系は抽象的であるため、果たして現実の「計算」と同一視しても良いのか疑問視され、周囲からの納得を得るには至らなかった。
    一方で Alan Turing や Emil Post はそれぞれ独立に、計算をテープ上の文字列の読み書きとして定式化し、仮想的ではあるがより具体的な計算機を構築した。
    これは後に「Turing 機械」と呼ばれる。
  >
  \p<
    こうして、再帰関数, ラムダ計算, Turing 機械という、全く異なるアプローチをとった 3 つの「計算」の定義が現れた。
    しかし驚くべきことに、Stephen Kleene 等による解析の結果、これら 3 つの定義は全く同じ関数のクラスを定めていることが明らかになった。
    どのアプローチをとっても同じ結論に達したというこの事実は、「計算」という概念の正当性を裏付けるものであった。
    このようにして、「計算」とは何なのかを巡る論争には終止符が打たれた。
  >
  \p<
    歴史についてはこの辺りにして本題に移ろう。
    まず、計算できるかどうかを判定する対象としては、自然数から自然数への多価関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> を考えることにする。
    というのも、(これは後々しっかり議論することになるが) だいたいのデータは自然数に変換することができるため、自然数上の関数を考えれば十分であるからである。
    さらに、計算というのは終わらない可能性がある。
    そのため、値が必ずしも定まるとは限らない関数を考えたい。
    そこで、これを次のように定式化する。
  >
  \thm|type="def"|<
    \p<
      部分集合 &m<A \subseteq; \sp<\bb<N>><k>> に対して、関数 &m<f: A \to; \bb<N>> のことを &m<\sp<\bb<N>><k>> 上の \def<部分関数\fl<partial function>> と呼び、&m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> と書く。
      このとき、&m<A> を &m<f> の \def<定義域\fl<domain>> と呼び、&m<\op<dom> (f)> で表す。
    >
  >
  \p<
    今後は、基本的に部分関数を扱っていくことになる。
    そのため、全ての値が定義されるような関数の方を特殊扱いしたいため、これに専用の名前をつけておく。
  >
  \thm|type="def"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> が &m<\op<dom> (f) = \sp<\bb<N>><k>> を満たすとき、&m<f> は \def<全域\fl<total>> であるという。
    >
  >
  \p<
    すなわち、全域関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> とは、普通の意味での関数 &m<f: \sp<\bb<N>><k> \to; \bb<N>> のことである。
  >
  \p<
    さて、今後の議論のためにいくつかの記法や用語を用意しておこう。
    まず、我々は自然数から自然数への多価 (部分) 関数を扱うため、&m<\sp<\bb<N>><k>> の元を考えることが多い。
    この元は &m<k> 個の自然数の組 &m<(\sb<x><1>, \cdots;, \sb<x><k>)> であるが、これをまとめて &m<\vec<x>> のように書くことにする。
    逆に、&m<\vec<x> \in; \sp<\bb<N>><k>> を構成する各自然数のことは &m<\sb<x><1>, \cdots;, \sb<x><k>> のように添え字を付けて表すが、このときは一貫して添字を 1 から始めることにする。
  >
  \p<
    加えて、部分関数を扱う上での便利な用語も用意しておく。
  >
  \thm|type="def"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> および元 &m<\vec<x> \in; \sp<\bb<N>><k>> を考える。
      &m<\vec<x> \in; \op<dom> (f)> であるとき、&m<f (\vec<x>)> は \def<定義されている\fl<defined>> といい、&m<f (\vec<x>) \darr|ord|;> と書く。
      逆に &m<\vec<x> \nin; \op<dom> (f)> であるときは、&m<f (\vec<x>)> は \def<定義されていない\fl<undefined>> といい、&m<f (\vec<x>) \uarr|ord|;> と書く。
    >
  >
  \p<
    定義されないことを表す &m<\uarr|ord|;> という記号は、部分関数を定めるときにも利用することがある。
    例えば、
    &mb<
      \array|align="rrcl"|<
        \c<f:> \c<\sp<\bb<N>><2>> \c<\dot<\longto;>> \c<\bb<N>> \br;
        \c; \c<(x, y)> \c<\longmapsto;> \c<\case<
          \c<x - y> \c<(x \geq; y)> \br;
          \c<\uarr|ord|;> \c<(x `< y)>
        >>
      >
    >
    と書いたら、&m<f> は定義域を &m<`{ (x, y) \mid; x \geq; y `} \subseteq; \sp<\bb<N>><2>> とする部分関数である。
  >
  \p<
     部分関数の値を比較することは頻繁にあるが、部分関数の値は定義されないことがあるので少し注意が必要である。
     以降、特に指示がない場合、&m<f (\vec<x>) = g (\vec<y>)> という形の等式が成立するとは、両辺 &m<f (\vec<x>)>, &m<g (\vec<y>)> が両方定義されていて等しいか両方とも定義されていないかのいずれかであるときとする。
     したがって、両辺を定める部分関数の定義域がズレていたら等式は成立していないことになる。
  >
  \p<
    また、 部分関数の値を組み合わせることもよくあるが、特に指示がなければ、式の一部が定義されない場合は式全体が定義されないこととする。
    例えば、
    &mb<
      \array|align="rrcl"|<
        \c<f:> \c<\sp<\bb<N>><2>> \c<\dot<\longto;>> \c<\bb<N>> \br;
        \c; \c<(x, y)> \c<\longmapsto;> \c<\case<
          \c<x - y> \c<(x \geq; y)> \br;
          \c<\uarr|ord|;> \c<(x `< y)>
        >>
      > \qquad;
       \array|align="rrcl"|<
        \c<g:> \c<\bb<N>> \c<\dot<\longto;>> \c<\bb<N>> \br;
        \c; \c<x> \c<\longmapsto;> \c<\case<
          \c<x `/ 2> \c<(&raw<&m<x> は偶数>)> \br;
          \c<\uarr|ord|;> \c<(&raw<&m<x> は奇数>)>
        >>
      >
    >
    と定義した場合、&m<x \in; \bb<N>> に対して &m<f (g (x), 3)> という式は、&m<x> が奇数であれば &m<g (x)> が定義されないので全体も定義されず、さらに &m<x> が偶数であっても &m<g (x)> が 3 未満であれば定義されない。
    したがって、
    &mb<
      \array|align="rrcl"|<
        \c<h:> \c<\bb<N>> \c<\dot<\longto;>> \c<\bb<N>> \br;
        \c; \c<x> \c<\longmapsto;> \c<f (g (x), 3)>
      >
    >
    と定めると、この式の字面だけを見れば全域関数に見えるが、実際にはその定義域は &m<`{ x \mid; &raw<&m<x> は偶数かつ &m<x `/ 2 \geq; 3>> `} \subset; \bb<N>> である。
  >
  \p<
    準備は以上にしよう。
    次回からは、再帰関数の理論を展開していく。
  >
  \h1<参考文献>
  \ol<
    \li|id="ectx"|<H. B. Enderton (2011)『Computability Theory』Academic Press>
  >

>