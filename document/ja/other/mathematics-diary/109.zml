\zml?|version="1.1"|;
\xml?|version="1.0",encoding="UTF-8"|;


\page<
  \name<計算可能ならば一般再帰的>
  \use-math|prefix="12"|;

  \h1<日記 (2026 年 1 月 21 日)>
  \p<
    前回は、一般再帰関数が全て計算可能であることを示した。
    今回は、この逆、すなわち計算可能関数が全て一般再帰的であることを示す。
  >
  \p<
    この証明の方針は、レジスタマシンの動作を全て一般再帰的関数で表現することである。
    しかし、一般再帰関数は自然数上の関数であるから、そのためにはプログラムやメモリを自然数で表す必要があるので、まずはその方法を整備しよう。
    なお、以降は自然数列の操作を各所で行うため、必要であれば\a|href="102.html"|<第 5 回>を読み直して記号などを確認しておいてほしい。
  >
  \p<
    初めに、命令やプログラムを自然数にエンコードしよう。
    このように形式機械のデータを自然数で表現したものは、一般に「Gödel 数」と呼ばれている。
  >
  \thm|type="def"|<
    \p<
      命令 &m<c> に対して自然数 &m<\lceil; c \rceil;> を、
      &mb<
        \array|align="rcl"|<
          \c<\lceil; \tt<inc> \srel; r \rceil;> \c<\coloneqq;> \c<\langle; 0, r \rangle;> \br;
          \c<\lceil; \tt<dec> \srel; r \rceil;> \c<\coloneqq;> \c<\langle; 1, r \rangle;> \br;
          \c<\lceil; \tt<forward> \srel; q \rceil;> \c<\coloneqq;> \c<\langle; 2, q \rangle;> \br;
          \c<\lceil; \tt<backward> \srel; q \rceil;> \c<\coloneqq;> \c<\langle; 3, q \rangle;> \br;
        >
      >
      によって定義する。
      これを &m<c> の \def<Gödel 数\fl<— number>> と呼ぶ。
    >
  >
  \thm|type="def"|<
    \p<
      プログラム &m<\scr<F> \eqqcolon; (\sb<c><0>, \cdots;, \sb<c><l - 1>)> に対して自然数 &m<\lceil; \scr<F> \rceil;> を、
      &mb<
        \lceil; \scr<F> \rceil; \coloneqq; \langle; \lceil; \sb<c><0> \rceil;, \cdots;, \lceil; \sb<c><l - 1> \rceil; \rangle;
      >
      によって定義する。
      これを &m<\scr<F>> の \def<Gödel 数\fl<— number>> と呼ぶ。
    >
  >
  \p<
    例えば、プログラム
    &mb<
      \array|align="l"|<
        \c<\tt<dec> \srel; 0> \br;
        \c<\tt<forward> \srel; 3> \br;
        \c<\tt<inc> \srel; 1> \br;
        \c<\tt<backward> \srel; 3>
      >
    >
    を &m<\scr<F>> とすると、この Gödel 数 &m<\lceil; \scr<F> \rceil;> は、
    &mb<
      \array|align="rcl"|<
        \c<\lceil; \scr<F> \rceil;> \c<=> \c<\langle; \lceil; \tt<dec> \srel; 0 \rceil;, \lceil; \tt<forward> \srel; 3 \rceil;, \lceil; \tt<inc> \srel; 1 \rceil;, \lceil; \tt<backward> \srel; 3 \rceil; \rangle;> \br;
        \c; \c<=> \c<\langle; \langle; 1, 0 \rangle;, \langle; 2, 3 \rangle;, \langle; 0, 1 \rangle;, \langle; 3, 3 \rangle; \rangle;> \br;
        \c; \c<=> \c<\langle; \sp<2><2> \cdot; \sp<3><1>, \sp<2><3> \cdot; \sp<3><4>, \sp<2><1> \cdot; \sp<3><2>, \sp<2><4> \cdot; \sp<3><4> \rangle;> \br;
        \c; \c<=> \c<\langle; 12, 648, 18, 1296 \rangle;> \br;
        \c; \c<=> \c<\sp<2><13> \cdot; \sp<3><649> \cdot; \sp<5><19> \cdot; \sp<7><1297>>
      >
    >
    となる。
    見ての通り巨大な数になるが、重要なのは数そのものではなく、この数だけからプログラムの情報を完全に復元できる点である。
    例えば、&m<\scr<F>> の最初の命令の Gödel 数 &m<\lceil; \tt<dec> \srel; 0 \rceil;> は、&m<\lceil; \scr<F> \rceil; @ 0> として取得できる。
    さらに、この命令がどの種類なのか知りたければ、&m<\lceil; \scr<F> \rceil; @ 0 @ 0> を見てそれが 0 から 3 までのいずれであるかを確認すれば良い。
  >
  \p<
    さて、これでプログラムを自然数にエンコードすることはできたので、次にレジスタマシンの状況を自然数にエンコードしよう。
    レジスタマシンの状況とはメモリとポインタのことであったが、ポインタはそもそもただの自然数なので、メモリをエンコードできれば良い。
    そのメモリとは、有限個を除いて 0 であるような自然数の列であった。
    これのエンコーディングは、有限列のエンコーディングと同様にして、次のように素数の冪で定義することにする。
  >
  \thm|type="def"|<
    \p<
      レジスタマシンのメモリ &m<\scr<R> \eqqcolon; (\sb<x><r>) \sb<><r \in; \bb<N>>> に対して自然数 &m<\lceil; \scr<R> \rceil;> を、
      &mb<
        \lceil; \scr<R> \rceil; \coloneqq; \prod<r \in; \bb<N>> \op<pr> (r) \sp<><\sb<x><r>>
      >
      によって定義する。
      これを &m<\scr<R>> の \def<Gödel 数\fl<— number>> と呼ぶ。
    >
  >
  \p<
    有限列のエンコーディングとは異なり、指数に 1 をたしていないことに注意してほしい。
    メモリを構成する自然数は有限個を除いて 0 なので、これによって上の積は実際には有限積になっており、問題なく定義されることが保証されている。
  >
  \p<
    メモリの Gödel 数から各レジスタの値を復元することも可能であり、さらに言えば原始再帰的に可能である。
  >
  \thm|type="prp",id="atinf"|<
    \p<
      原始再帰関数 &m<\sp<\atsym|ord|;><*>: \sp<\bb<N>><2> \to; \bb<N>> であって、任意のメモリ &m<(\sb<x><r>) \sb<><r \in; \bb<N>>> と自然数 &m<y> に対し、
      &mb<
        \lceil; (\sb<x><r>) \sb<><r \in; \bb<N>> \rceil; \sp<\atsym|bin|;><*> y = \sb<x><y>
      >
      を満たすものが存在する。
    >
  >
  \prf<
    \p<
      有限列の場合と同様に、メモリの Gödel 数 &m<`r> に対して、&m<\op<pr> (y) \sp<><1>>, &m<\op<pr> (y) \sp<><2>>, &m<\cdots;> が順に &m<`r> をわり切るか調べていけば良い。
      したがって、
      &mb<
        `r \sp<\atsym|bin|;><*> y \coloneqq; \bar<\rm<`m>> t `< `r. \srel; \op<pr> (y) \sp<><t + 1> \nmid; `r
      >
      と定義すれば良い。
    >
  >
  \p<
    以上で、レジスタマシンに関するデータを全て自然数にエンコードする方法が整った。
    残る作業は、このエンコーディングを用いてレジスタマシンの動作を一般再帰関数として表現することである。
    とはいえ、そのアイデアはほとんど\a|href="108.html"|<第 9 回>でレジスタマシンの厳密な形式化として述べた通りである。
    すなわち、命令による状況の変化を関数 next として表現し、それを用いて特定のステップにおける状況を取得する関数 configat を定めるのである。
  >
  \p<
    まずは next を原始再帰的に定義できることを示そう。
    なお、\a|href="108.html"|<第 9 回>のときと同様に、定義上実行が終了している状態でもさらなる実行が可能であると見なし、その場合はレジスタマシンの状況は変化しなかったものとする。
    また、異常終了する場合を考える必要はないため、
  >
  \thm|type="prp"|<
    \p<
      次を満たす原始再帰関数 &m<\op|ord|<next>: \sp<\bb<N>><2> \to; \bb<N>> が存在する。
      任意のプログラム &m<\scr<F>> をとり、レジスタマシンの状況が &m<(\scr<R>, p)> である状態で 1 ステップ実行した直後の状況を &m<(\scr<R>', p')> とする。
      この 1 ステップの実行の前でも後でも異常終了していないのであれば、
      &mb<
        \op<next> (\lceil; \scr<F> \rceil;, \langle; \lceil; \scr<R> \rceil;, \lceil; p \rceil; \rangle;) = \langle; \lceil; \scr<R>' \rceil;, \lceil; p' \rceil; \rangle;
      >
      が成り立つ。
    >
  >
  \thm|type="prp"|<
    \p<
      次を満たす原始再帰関数 &m<\op|ord|<configat>: \sp<\bb<N>><3> \to; \bb<N>> が存在する。
      任意のプログラム &m<\scr<F>> をとる。
      初期のメモリが &m<\scr<R>> である状態から &m<n> ステップ実行した直後のレジスタマシンの状況を &m<(\sp<\scr<R>><n>, \sp<p><n>)> とする。
      この途中で異常終了していないのであれば、
      &mb<
        \op<configat> (\lceil; \scr<F> \rceil;, \lceil; \scr<R> \rceil;, n) = \langle; \lceil; \sp<\scr<R>><n> \rceil;, \lceil; \sp<p><n> \rceil; \rangle;
      >
      が成り立つ。
    >
  >
  \thm|type="prp",id="run"|<
    \p<
      次を満たす一般再帰関数 &m<\op|ord|<run>: \sp<\bb<N>><k + 1> \dot<\to;> \bb<N>> が存在する。
      任意のプログラム &m<\scr<F>> をとり、自然数列 &m<\vec<x> \in; \sp<\bb<N>><k>> に対して初期のメモリが &m<(\sb<x><0>, \cdots;, \sb<x><k - 1>, 0, \cdots;)> である状態でこれを実行したとすると、以下がともに成り立つ。
    >
    \ul<
      \li<
        実行が正常終了するならば、そのときの &m<k> 番目のレジスタの値が &m<y> とすると、&m<\op<run> (\lceil; \scr<F> \rceil;, \vec<x>) = y> が成り立つ。
      >
      \li<
        実行が永遠に終了しないならば、&m<\op<run> (\lceil; \scr<F> \rceil;, \vec<x>)> は定義されない。
      >
    >
  >
  \thm|type="thm",id="compgenrec"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> に対し、&m<f> が計算可能ならば、&m<f> は一般再帰的である。
    >
  >
  \prf<
    \p<
      &m<f> が計算可能であれば、それを計算するプログラム &m<\scr<F>> が存在する。
      ここで、部分関数 &m<f': \sp<\bb<N>><k> \dot<\to;> \bb<N>> を &m<f' (\vec<x>) \coloneqq; \op<run> (\lceil; \scr<F> \rceil;, \vec<x>)> によって定めると、\mref|type="thm",ref="run"|; より run は一般再帰的なので、&m<f'> も一般再帰的である。
      さらに、\mref|type="thm",ref="run"|; で述べられている run の性質は、まさに &m<\scr<F>> が &m<f'> を計算することを述べている。
      すなわち &m<f = f'> であるから、&m<f> は一般再帰的である。
    >
  >
  \thm|type="thm",id="equiv"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> に対し、&m<f> が一般再帰的であることと &m<f> が計算可能であることは同値である。
    >
  >
  \prf<
    \p<
      \a|href="108.html#genreccomp"|<定理 11.4> と\mref|type="thm",ref="compgenrec"|; から分かる。
    >
  >
  \p<
    これにより、一般再帰性と計算可能性は、定義の方針は異なるものの全く同じ性質であることが分かった。
    「計算できる」ことを定式化するための別々のアプローチが結局同じものに行き着いたわけなので、この性質こそが、我々が直感的に「計算できる」と思える関数の正しい定式化だと言えるだろう。
  >
  \h1<参考文献>
  \ol<
    \li|id="ectx"|<H. B. Enderton (2011)『Computability Theory』Academic Press>
  >

>