\zml?|version="1.1"|;
\xml?|version="1.0",encoding="UTF-8"|;


\page<
  \name<Kleene の正規形定理>
  \use-math|prefix="14"|;

  \h1<日記 (2026 年 2 月 12 日)>
  \p<
    前回は、計算可能性に関するトピックとして、列挙定理と停止性問題の計算不可能性を扱った。
    今回は、別のトピックとして、Kleene の正規形定理を扱う。
  >
  \p<
    Kleene の正規形定理とは、どんな計算可能関数でも「原始再帰関係に 1 回の最小化を施した後に原始再帰関数で最終結果を抽出する」という形で表せることを主張する定理である。
    定義によれば、計算可能関数とは、初期関数から始めて合成と原始再帰と最小化を自由に組み合わせて得られるような関数のことだが、実はその組み合わせ方として「原始再帰関係\k<→>最小化\k<→>原始再帰関数」という形だけで十分だということである。
  >
  \p<
    実は、この定理の証明の本質的な部分は\a|href="109.html#run"|<命題 12.8> ですでに行っている。
    そこで、これを示した\a|href="109.html"|<第 12 回>の内容を思い出すことにしよう。
    この回ではまず、プログラムの Gödel 数 &m<`f> と初期メモリの Gödel 数 &m<`r> およびステップ数 &m<n> を渡すと、そのプログラムを &m<n> ステップ実行した直後の状況を返す関数 configat を構成した。
    すると、同じ &m<`f> と &m<`r> を渡したときに、プログラムが (もし正常終了するなら) 正常終了するステップ数を返す関数 &m<\sb<n><\infty;>> は、
    &mb<
      \sb<n><\infty;> (`f, `r) \coloneqq; \rm<`m> n. \srel; \op<configat> (`f, `r, n) @ 1 = \op<len> (`f)
    >
    と定義できるのだった。
    ここで、このプログラムが部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> を計算するとすれば、これは、関数への引数をレジスタマシンの初期メモリに変換する関数 tomem を使って、
    &mb<
      f (\vec<x>) = \op<configat> (`f, \op<tomem> (\vec<x>), \sb<n><\infty;> (`f, \op<tomem> (\vec<x>))) @ 0 \sp<@><*> k 
    >
    と書けるのだった。
  >
  \p<
    この観察をまとめると、関係 &m<\op|ord|<Haltat> \subseteq; \sp<\bb<N>><k + 2>> を
    &mb<
      \op<Haltat> (`f, \vec<x>, n) \coloniff; \op<configat> (`f, \op<tomem> (\vec<x>), n) @ 1 = \op<len> (e)
    >
    で定め、関数 &m<\op|ord|<ext>: \sp<\bb<N>><k + 2> \to; \bb<N>> を
    &mb<
      \op<ext> (`f, \vec<x>, n) \coloneqq; \op<configat> (`f, \op<tomem> (\vec<x>), n) @ 0 \sp<@><*> k
    >
    で定めれば、
    &mb<
      f (\vec<x>) = \op<ext> (`f, \vec<x>, \rm<`m> n. \sfun; \op|ord|<Haltat> (`f, \vec<x>, n))
    >
    と書けるということになる。
    つまり、&m<f> の値を「&m<\op|ord|<Haltat>> に最小化を施して &m<\op|ord|<ext>> を適用した結果」として書けたことになる。
    さらに、ここまでの構成を追えば、ここに現れている &m<\op|ord|<Haltat>> と &m<\op|ord|<ext>> がともに原始再帰的であることも分かる。
    これによって、計算可能関数を「原始再帰関係に 1 回の最小化を施した後に原始再帰関数で最終結果を抽出する」という形で表すという最初に述べた目標は一応達成されたことになる。
  >
  \p<
    ただし、Kleene の正規形定理はより強く、外側にある &m<\op|ord|<ext>> を &m<`f> にも &m<\vec<x>> にも依存せず最小化の結果だけに依存する形にしても、上記のように書けることを主張する。
    幸いこれは、&m<\op|ord|<Haltat>> の定義を次のように少し変えて、最小化をとる変数に (ステップ数だけでなく) メモリの情報を加えておくことで証明できる。
  >
  \thm|type="prp",id="haltat"|<
    \p<
      次を満たす原始再帰関係 &m<\sp<\op|ord|<Haltat>><(k)> \subseteq; \sp<\bb<N>><k + 2>> が存在する。
      任意のプログラム &m<\scr<F>> と自然数列 &m<\vec<x> \in; \sp<\bb<N>><k>> に対し、初期のメモリが &m<(\sb<x><0>, \cdots;, \sb<x><k - 1>, 0, \cdots;)> である状態から &m<\scr<F>> を実行することを考える。
      この途中で異常終了しないならば、自然数 &m<`n> に対して以下は同値である。
    >
    \ul<
      \li<
        &m<\sp<\op<Haltat>><(k)> (\lceil; \scr<F> \rceil;, \vec<x>, `n)> が成り立つ。
      >
      \li<
        ある自然数 &m<n> が存在して、&m<n> ステップ実行直後のメモリを &m<\sb<\scr<R>><n>> と書くことにすると、&m<\sb<\scr<R>><n>> は正常終了している状態であり、さらに &m<`n @ 0 = n > および &m<`n @ 1 = \lceil; \sb<\scr<R>><n> \rceil;> も成り立つ。
      >
    >
  >
  \prf<
    \p<
      これは、
      &mb<
        \array|align="rcl"|<
          \c<\op<Haltat> (`f, \vec<x>, `n)> \c<\coloniff;> \c<\op<configat> (\lceil; \scr<F> \rceil;, \op<tomem> (\vec<x>), `n @ 0) = \langle; `n @ 1, \op<len> (`f) \rangle;> \br;
        >
      >
      とすれば良い。
      実際、この右辺には原始再帰的な関数や操作しか含まれていないので、この Haltat は原始再帰的である。
      さらに、\a|href="109.html#configat"|<命題 12.7> で述べられている configat の性質により、以下の 2 条件が同値であることが分かる。
    >
    \ul<
      \li<
        上記の Haltat について、&m<\op<Haltat> (\lceil; \scr<F> \rceil;, \vec<x>, `n)> が成り立つ。
      >
      \li<
        &m<n \coloneqq; `n @ 0> とおいて、&m<n> ステップ実行直後の状況を &m<(\sb<\scr<R>><n>, \sb<p><n>)> とすれば、&m<\lceil; \sb<\scr<R>><n> \rceil; = `n @ 1> かつ &m<\sb<p><n> = \op<len> (\lceil; \scr<F> \rceil;)> が成り立つ。
      >
    >
    \p<
      この後者の条件にある &m<\sb<p><n> = \op<len> (\lceil; \scr<F> \rceil;)> であるとは、&m<n> ステップ時点で正常終了の状態であるということである。
      したがって、この条件は、命題の主張の 2 番目の条件と同値である。
    >
  >
  \p<
    これを用いると、以下の Kleene の正規形定理が証明できる。
  >
  \thm|type="thm",id="kleene"|<
    \name<Kleene の正規形定理\fl<—’s normal form theorem>>
    \p<
      次を満たす原始再帰関係 &m<\sp<\op|ord|<Haltat>><(k)> \subseteq; \sp<\bb<N>><k + 2>> と原始再帰関数 &m<\sp<\op|ord|<ext>><(k)>: \bb<N> \to; \bb<N>> が存在する。
      任意の計算可能関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> に対し、ある自然数 &m<e \in; \bb<N>> が存在して、任意の自然数列 &m<\vec<x> \in; \sp<\bb<N>><k>> に対し、
      &mb<
        f (\vec<x>) = \sp<\op<ext>><(k)> (\rm<`m> t. \sfun; \sp<\op<Haltat>><(k)> (e, \vec<x>, t))
      >
      が成り立つ。
    >
  >
  \prf<
    \p<
      &m<f> を計算するプログラムを &m<\scr<F>> として、&m<e \coloneqq; \lceil; \scr<F> \rceil;> と定める。
      まず、\mref|type="thm",ref="haltat"|; の通りに &m<\op|ord|<Haltat>> をとり、自然数列 &m<\vec<x> \in; \sp<\bb<N>><k>> に対して、
      &mb<
        \sb<`n><\infty;> (e, \vec<x>) \coloneqq; \rm<`m> t. \sfun; \op<Haltat> (e, \vec<x>, t)
      >
      とおく。
      すると\mref|type="thm",ref="haltat"|; により、初期のメモリが &m<(\vec<x>, 0, \cdots;)> である状態から &m<\scr<F>> を実行したときに、それが正常終了する最小のステップ数が &m<\sb<`n><\infty;> (e, \vec<x>) @ 0> として得られ、そのときのメモリの Gödel 数が &m<\sb<`n><\infty;> (e, \vec<x>) @ 1> になる。
      したがって、計算の定義により &m<f (\vec<x>) = \sb<`n><\infty;> (e, \vec<x>) @ 1 \sp<@><*> k> である。
      そこで、関数 &m<\op|ord|<ext>: \bb<N> \to; \bb<N>> を
      &mb<
        \op<ext> (`n) \coloneqq; `n @ 1 \sp<@><*> k
      >
      で定めれば、これは原始再帰的であり、さらに
      &mb<
        \array|align="rcl"|<
          \c<f (\vec<x>)> \c<=> \c<\sb<`n><\infty;> (e, \vec<x>) @ 1 \sp<@><*> k> \br;
          \c; \c<=> \c<\op<ext> (\rm<`m> t. \sfun; \op|ord|<Haltat> (e, \vec<x>, t))> \br;
        >
      >
      が成り立つ。
      Haltat も ext も &m<f> には依存していないため、これらは定理の主張を満たす。
    >
  >
  \p<
    次回からは、新たに計算可枚挙性という概念を導入し、その性質を見ていくことにする。
  >
  \h1<参考文献>
  \ol<
    \li|id="ectx"|<H. B. Enderton (2011)『Computability Theory』Academic Press>
  >

>