\zml?|version="1.1"|;
\xml?|version="1.0",encoding="UTF-8"|;


\page<
  \name<レジスタマシン>
  \use-math|prefix="9"|;

  \h1<日記 (2026 年 1 月 14 日)>
  \p<
    前回までは、「計算できる」ことを定式化するためのアプローチとして、限られた操作で閉じた関数のクラスを考え、結果的に一般再帰関数のクラスを得た。
    今回からは、より直接的に「計算」というプロセスを扱う形式的な機械を考えることにする。
    形式的な機械というと Turing マシンを導入するのが伝統的だが、ここでは Enderton\mref|type="ref",ref="ectx"|; に倣って、より現代のコンピュータに近く動作が直感的なレジスタマシンを導入することにする。
  >
  \p<
    レジスタマシンとは、名前の通りレジスタを備えた抽象的な機械のことで、このレジスタを特定の手続きに従って書き換えていくことで計算を行う。
    まずはレジスタを定義しよう。
  >
  \thm|type="def"|<
    \p<
      有限個を除いて 0 であるような自然数の列 &m<(\sb<x><r>) \sb<><r \in; \bb<N>>> をレジスタマシンの \def<メモリ\fl<memory>> と呼ぶ。
      また、各 &m<r \in; \bb<N>> に対して、数 &m<\sb<x><r>> は &m<r> 番目の \def<レジスタ\fl<register>> に格納されているという。
    >
  >
  \p<
    定義上、メモリは自然数で添字付けられており、すなわちレジスタは無限個ある。
    しかし、「有限個を除いて 0 であるような」という条件を課していることからも分かるように、これはあくまで「計算をするのに十分な個数のレジスタが常に確保されている」という意味である。
    計算の途中で真に無限個のレジスタを使うことはなく、十分大きな番号以降のレジスタを触ることはない。
  >
  \p<
    さて、レジスタマシンはこのレジスタを操作することで計算を行うが、その操作としては次の 4 種類を考える。
  >
  \thm|type="def"|<
    \p<
      &m<\tt<inc> \srel; r, \tt<dec> \srel; r, \tt<forward> \srel; q, \tt<backward> \srel; q \srel; (r, q \in; \bb<N>)> のいずれかの形のものをレジスタマシンの \def<命令\fl<instruction>> と呼ぶ。
      また、命令の有限列を \def<プログラム\fl<program>> と呼ぶ。
    >
  >
  \p<
    レジスタマシンはプログラムを渡されると、まずプログラムの最初 (0 番目) の命令を見る。
    以降は、そのときに見た命令に従って、必要であればレジスタの数を書き換えた後に次に見る命令を決めることを繰り返す。
    各命令の意味は次の通りである。
  >
  \ul<
    \li*<
      &m<\tt<inc> \srel; r> を見た場合、&m<r> 番目のレジスタの値を 1 だけ増やし、プログラム上の次の命令を見る。
    >
    \li*<
      &m<\tt<dec> \srel; r> を見た場合、&m<r> 番目のレジスタの値が 0 であれば、何もせずにプログラム上の次の命令を見る。
      &m<r> 番目のレジスタの値が正であれば、その値を 1 だけ減らし、プログラム上の次の次の命令を見る。
      すなわち、この命令は場合分けも兼ねている。
    >
    \li*<
      &m<\tt<forward> \srel; q> を見た場合、何もせずに、プログラム上の &m<q> 個先の命令を見る。
    >
    \li*<
      &m<\tt<backward> \srel; q> を見た場合、何もせずに、プログラム上の &m<q> 個前の命令を見る。
    >
  >
  \p<
    各命令には実行後にどの命令を見るべきかが明示されている。
    この際、次に見るべき命令が存在しない場合がある。
    例えば、&m<\tt<inc> \srel; 0> だけから成るプログラムを実行すると、レジスタマシンはまず 0 番目のレジスタの値を増やした後、その次の命令を見ようとするが、次にはもう命令はない。
    また、&m<\tt<backward> \srel; 5> だけから成るプログラムを実行すると、レジスタマシンは次にこの 5 個前の命令を見ようとするが、そもそもこれが最初の命令なので 5 個前の命令など存在しない。
    このように次に見るべき命令がなかったら、プログラムの実行は終了したということにする。
    これが唯一の終了条件である。
  >
  \p<
    しかし、一概に「次に見るべき命令がない」と言っても、&m<\tt<inc> \srel; 0> と &m<\tt<backward> \srel; 5> とでは意味合いが異なる。
    &m<\tt<inc> \srel; 0> の実行では、命令の定義に従って直後の命令を見ようとしたわけだが、これが最後の命令であるがために見るべき命令が存在しない状況になった。
    つまり、プログラム全体の実行が最後まで辿り着いた結果として次に見るべき命令が存在しない状況になったと考えられるため、これは正常な終了と見なせるだろう。
    しかし、 &m<\tt<backward> \srel; 5> の実行では、この 5 個前 (つまり &m<-5> 番目) という異常な場所を見ようとして、命令が存在しない状況になった。
    これは、そのような変な場所を見させようとしたプログラムが異常だったと言えるため、この場合はエラーによる終了と見なすのが自然に思える。
    この違いを明確にしておこう。
  >
  \thm|type="def"|<
    \p<
      レジスタマシンが長さ &m<l> のプログラムを実行した結果、&m<l> 番目 (最後の命令の次) の命令を見ようとして終了した場合、レジスタマシンは \def<正常終了した\fl<halt gracefully>> という。
      それ以外の命令を見ようとして終了した場合は、レジスタマシンは \def<異常終了した\fl<halt abnormally>> という。
    >
  >
  \p<
    ちなみに、プログラムの末尾には &m<\tt<end>> のような特殊な命令を常に追加することにして、レジスタマシンが &m<\tt<end>> を見たらそこで正常終了と見なし、&m<\tt<end>> を含めても存在しない命令を見ようとしたら異常終了と見なす、と考えても同じことである。
    こちらの解釈の方が直感的かもしれない。
  >
  \p<
    なお、プログラムの実行は永遠に (正常にも異常にも) 終了しない可能性もあることにも注意したい。
    例えば、&m<\tt<forward> \srel; 0> だけから成るプログラムを実行すると、レジスタマシンは次に 0 個先の命令を見ることになるが、それは &m<\tt<forward> \srel; 0> 自身なので、永遠に &m<\tt<forward> \srel; 0> を見続けることになる。
    すなわち、次に見るべき命令が存在しない状況にはならないため、このプログラムの実行は永遠に終了しない。
  >
  \p<
    さて、ここまでレジスタマシンの動作を自然言語で述べてきたが、もう少し数学的に厳密な見方もしておこう。
    レジスタマシンはレジスタをもっており、このレジスタはプログラムの実行中に内容が書き換わる。
    一方で、レジスタマシンは「プログラム上の何番目の命令を見るか」という情報も保持しており、これもプログラムの実行中に変化する。
    これを仮に「ポインタ」と呼ぶことにしよう。
    すると、レジスタマシンはレジスタとポインタを「状況」としてもち、プログラムの命令とはこの状況を別の状況に変化させるものと見なすことができる。
    したがって、プログラム &m<\scr<F> \coloneqq; (\sb<c><0>, \cdots;, \sb<c><l - 1>)> を実行するレジスタマシンの動作は、レジスタ &m<\vec<x>> とポインタ &m<p> の対である状況 &m<(\vec<x>, p)> を受け取って、それを 1 ステップ実行した後の状況 &m<(\vec<x>', p')> を返す写像 &m<\sb<\op|ord|<next>><\scr<F>>> として定式化できる。
    この写像は、
    &mb<
      \array|align="rcl"|<
        \c<\sb<\op|ord|<next>><\scr<F>> (\vec<x>, p)> \c<\coloneqq;> \c<\case<
          \c<((\sb<x><0>, \cdots;, \sb<x><r - 1>, \sb<x><r> + 1, \sb<x><r + 1>, \cdots;), p + 1)> \c<(\sb<c><p> = \tt<inc> \srel; r)> \br;
          \c<(\vec<x>, p + 1)> \c<(\sb<c><p> = \tt<dec> \srel; r \scand; \sb<x><r> = 0)> \br;
          \c<((\sb<x><0>, \cdots;, \sb<x><r - 1>, \sb<x><r> - 1, \sb<x><r + 1>, \cdots;), p + 2)> \c<(\sb<c><p> = \tt<dec> \srel; r \scand; \sb<x><r> `> 0)> \br;
          \c<(\vec<x>, p + q)> \c<(\sb<c><p> = \tt<forward> \srel; q)> \br;
          \c<(\vec<x>, p - q)> \c<(\sb<c><p> = \tt<backward> \srel; q)> \br;
          \c<(\vec<x>, p)> \c<(&raw<&m<\sb<c><p>> が存在しない>)>
        >>
      >
    >
    と書ける。
    さて、初期のレジスタを &m<\vec<x>> として、&m<n> ステップ後のレジスタマシンの状況を &m<\sb<\op<configat>><\scr<F>> (\vec<x>)> と書くことにしよう。
    するとこれは、&m<\sb<\op|ord|<next>><\scr<F>>> を再帰的に呼び出すことで、
    &mb<
      \array|align="rcl"|<
        \c<\sb<\op<configat>><\scr<F>> (\vec<x>, 0)> \c<=> \c<(\vec<x>, 0)> \br;
        \c<\sb<\op<configat>><\scr<F>> (\vec<x>, n + 1)> \c<=> \c<\sb<\op|ord|<next>><\scr<F>> (\sb<\op<configat>><\scr<F>> (\vec<x>, n))>
      >
    >
    と定めることができる。
    これを使えば、プログラムが &m<n> ステップで終了することは、&m<\sb<\op<configat>><\scr<F>> (\vec<x>, n)> の右側成分が負になるか &m<l> 以上になることだと言える。
    特に、&m<n> ステップで正常終了することは、&m<\sb<\op<configat>><\scr<F>> (\vec<x>, n) = l> が成り立つことだと言える。
    したがって、この正常終了するときのステップ数を &m<\sbsp<n><\scr<F>><\infty;> (\vec<x>)> と書けば、正常終了時の状況は &m<\sb<\op<configat>><\scr<F>> (\vec<x>, \sbsp<n><\scr<F>><\infty;> (\vec<x>))> として取り出せる。
  >
  \p<
    このようにレジスタマシンの動作は数学的に厳密に述べられるとはいえ、形式化しすぎても直感的に理解しにくくなってしまうので、以降はレジスタマシンの動作は自然言語で説明することにする。
    もし厳密性が恋しくなったら、適宜ここで述べた表現に戻ってきて議論を書き直そうとしてみてほしい。
  >
  \p<
    さて、形式化についてはこの辺りにしておいて、具体的なプログラムを 1 つ見てみよう。
    最初のレジスタを &m<(5, 0, 0, \cdots;)> として、次のプログラムを実行することを考える。
    &mb<
      \array|align="l"|<
        \c<\tt<dec> \srel; 0> \br;
        \c<\tt<forward> \srel; 3> \br;
        \c<\tt<inc> \srel; 1> \br;
        \c<\tt<backward> \srel; 3>
      >
    >
    まず初めに &m<\tt<dec> \srel; 0> が実行されるが、0 番目のレジスタの値は現在 5 であるため、これが減って 4 になり、この後は次の次の命令を見ることになる。
    その命令とは &m<\tt<inc> \srel; 1> であるから、これにより 1 番目のレジスタの値が増えて 1 になる。
    次の命令は &m<\tt<backward> \srel; 3> であるから、これによりポインタは 3 つの前の命令すなわち &m<\tt<dec> \srel; 0> に戻る。
    すると最初と同様に、0 番目のレジスタがまた減って 3 になり、次に 1 番目のレジスタがさらに増えて 2 になり、また最初に戻る。
    これが何回か繰り替えされると、0 番目のレジスタが 0 になり 1 番目のレジスタが 5 になった状態で、最初に戻るときが訪れる。
    すると今回は、&m<\tt<dec> \srel; 0> が実行される際に 0 番目のレジスタが 0 になっているので、レジスタの数の減少は起こらずに、すぐ次の命令に進むことになる。
    その命令とは &m<\tt<forward> \srel; 3> であるから、ポインタは 3 つ後に進むが、その場所は最後の命令の直後である。
    したがって、ここでレジスタマシンは正常終了し、このときレジスタは &m<(0, 5, 0, \cdots;)> となっている。
    つまり、このプログラムは 0 番目のレジスタの値を 1 番目のレジスタに移すという操作を表しているわけである。
  >
  \p<
    では、レジスタマシンを用いて、自然数上の関数が「計算できる」ことを定義しよう。
  >
  \thm|type="def"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> とプログラム &m<\scr<F>> をとる。
      任意の &m<\vec<x> \in; \sp<\bb<N>><k>> に対して、レジスタを &m<(\sb<x><0>, \cdots;, \sb<x><k - 1>, 0, \cdots;)> に初期化した状態で &m<\scr<F>> を実行すると、次の 2 条件がともに成り立つとする。
    >
    \ul<
      \li*<
        &m<f (\vec<x>)> が定義されているならば、&m<\scr<F>> の実行後に &m<k> 番目のレジスタの値が &m<f (\vec<x>)> になった状態で正常終了する。
      >
      \li*<
        &m<f (\vec<x>)> が定義されていないならば、&m<\scr<F>> の実行は永遠に終了しない。
      >
    >
    \p<
      このとき、&m<\scr<F>> は &m<f> を \def<計算する\fl<compute>> という。
    >
  >
  \thm|type="def"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> をとる。
      &m<f> を計算するプログラムが存在するとき、&m<f> は \def<計算可能\fl<computable>> であるという。
    >
  >
  \p<
    例を挙げよう。
    定義の直前に見たプログラム
    &mb<
      \array|align="l"|<
        \c<\tt<dec> \srel; 0> \br;
        \c<\tt<forward> \srel; 3> \br;
        \c<\tt<inc> \srel; 1> \br;
        \c<\tt<backward> \srel; 3>
      >
    >
    は、0 番目のレジスタの値をそのまま 1 番目に移すものであった。
    定義に従えば、これは恒等関数 &m<\op|ord|<id>: \bb<N> \to; \bb<N>> を計算するプログラムと言える。
    したがって、恒等関数は計算可能であることが分かった。
  >
  \p<
    もちろん、より複雑な関数も計算可能である。
    次回は、どのような関数が計算可能になるかをより詳しく見ることにする。
  >
  \h1<参考文献>
  \ol<
    \li|id="ectx"|<H. B. Enderton (2011)『Computability Theory』Academic Press>
  >

>