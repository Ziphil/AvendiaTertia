\zml?|version="1.1"|;
\xml?|version="1.0",encoding="UTF-8"|;


\page<
  \name<自然数列のコーディング>
  \use-math|prefix="5"|;

  \h1<日記 (2025 年 12 月 26 日)>
  \p<
    前回までで、原始再帰的な範囲内で可能な演算を一通り列挙した。
    今回は、その応用として、素数に関するいくつかの関数とそれを用いた自然数列のコーディングについて考える。
    なお今後は、\a|href="101.html"|<前回>の最後にまとめた対象や操作が原始再帰的であることは、該当する命題や定理を明示することなく使用する。
  >
  \p<
    まずは
  >
  \thm|type="prp",id="prime"|<
    \p<
      関係 &m<\op|ord|<Prime> \subseteq; \bb<N>> を
      &mb<
        x \in; \op|ord|<Prime> \coloniff; &raw<&m<x> は素数>
      >
      で定めると、これは原始再帰的である。
    >
  >
  \prf<
    \p<
      素数とは、1 より大きくて自分自身未満の数の積で表せない数のことである。
      したがって、
      &mb<
        x \in; \op|ord|<Prime> \iff; x `> 1 \scand; \sp<><\forall;> q `< x \ssbin; \sp<><\forall;> r `< x  \ssbin; (x \neq; q \cdot; r)
      >
      であるが、右辺は原始再帰的なものの組み合わせであるから、&m<\op|ord|<Prime>> も原始再帰的である。
    >
  >
  \thm|type="prp",id="pr"|<
    \p<
      全域関数 &m<\op|ord|<pr>: \bb<N> \to; \bb<N>> を
      &mb<
        \op<pr> (x) \coloneqq; &raw<&m<x> 番目の素数>
      >
      で定めると、これは原始再帰的である。
      ただし、素数の番号は 0 から数えるものとする。
      すなわち、例えば &m<\op<pr> (0) = 2>, &m<\op<pr> (1) = 3>, &m<\cdots;> である。
    >
  >
  \prf<
    \p<
      &m<\op|ord|<pr>> を原始再帰の形で書くことを試みる。
      &m<\op<pr> (0) = 2> であるから、後は &m<\op<pr> (x + 1)> を &m<x> と &m<\op<pr> (x)> の式で表せば良い。
    >
    \p<
      &m<\op<pr> (x + 1)> とは &m<p \coloneqq; \op<pr> (x)> の次の素数のことだから、有界最小化演算子を用いて探せば良い。
      しかし、そのためには探す上界を決める必要がある。
      幸い、&m<p> の次の素数は必ず &m<p! + 1> 以下である。
      なぜなら、&m<p! + 1> は &m<p> 以下のどんな素数でもわり切れないため、&m<p! + 1> の素因数は全て &m<p> より大きい。
      すなわち、&m<p> より大きく &m<p! + 1> 以下の素数が存在することになるため、&m<p> の次の素数は少なくともこの範囲内にある。
    >
    \p<
      以上の考察から &m<\op|ord|<pr>> は、 
      &mb<
        \array|align="rcl"|<
          \c<\op<pr> (0)> \c<=> \c<2> \br;
          \c<\op<pr> (x + 1)> \c<=> \c<\bar<\rm<`m>> t `< \op<pr>(x) ! + 2. \srel; (t \in; \op|ord|<Prime> \scand; t `> \op<pr>(x))>
        >
      >
      という原始再帰の形で書ける。
      \mref|type="thm",ref="prime"|; によって &m<\op|ord|<Prime>> は原始再帰的であり、それ以外の演算も原始再帰的であることが分かっているため、この &m<\op|ord|<pr>> も原始再帰的である。
    >
  >
  \p<
    素因数分解の一意性を用いることで、自然数の列を可逆な方式で 1 つの自然数にコーディングすることができる。
    具体的には、次のようにすれば良い。
  >
  \thm|type="prp",id="coding"|<
    \p<
      全域関数 &m<\langle; \hyphen; \rangle;: \sp<\bb<N>><k> \to; \bb<N>> を
      &mb<
        \langle; \sb<x><0>, \cdots;, \sb<x><k - 1> \rangle; \coloneqq; \op<pr> (0) \sp<><\sb<x><0> + 1> \cdots; \op<pr> (k - 1) \sp<><\sb<x><k - 1> + 1>
      >
      で定めると、これは原始再帰的である。
    >
  >
  \prf<
    \p<
      \mref|type="thm",ref="pr"|; によって &m<\op|ord|<pr>> は原始再帰的であり、それ以外の演算も原始再帰的であることが分かっているため、この関数も原始再帰的である。
    >
  >
  \p<
    例えば、&m<\langle; 5, 2 \rangle; = \sp<2><6> \cdot; \sp<3><3> = 1728> や &m<\langle; 4, 1, 0, 3\rangle; = \sp<2><5> \cdot; \sp<3><2> \cdot; \sp<5><1> \cdot; \sp<7><4> = 3457440> などとなる。
    &m<k = 0> の場合は空配列のコーディングと見なすことができ、&m<\langle; \rangle; = 1> となる。
    とは言え、具体的な数値に特に意味はなく、原始再帰的な方法でコーディングが可能であるという点が重要である。
  >
  \p<
    この列のコーディングでは指数に 1 をたしているが、これはコーディングされた数からもとの列の長さを復元できるようにするためである。
    この取得ももちろん原始再帰的に可能である。
  >
  \thm|type="prp",id="len"|<
    \p<
      全域関数 &m<\op|ord|<len>: \bb<N> \to; \bb<N>> であって、任意の数 &m<\sb<x><0>, \cdots;, \sb<x><k - 1> \in; \bb<N>> に対し、
      &mb<
        \op<len> (\langle; \sb<x><0>, \cdots;, \sb<x><k - 1> \rangle;) = k
      >
      を満たすものが、原始再帰的な関数として存在する。
    >
  >
  \prf<
    \p<
      列のコーディングの定義から、コーディングを素因数分解したときに、指数が 0 になる最小の素数の番号がもともとの列の長さである。
      ある素数の指数が 0 であるとはその素数でわり切れないということなので、&m<\op|ord|<len>> は、
      &mb<
        \op<len> (s) \coloneqq; \bar<\rm<`m>> t `< s. \srel; \op<pr> (t) \nmid; s
      >
      と定義すれば良い。
      \mref|type="thm",ref="pr"|; によって &m<\op|ord|<pr>> は原始再帰的だから、この関数も原始再帰的である。
    >
  >
  \p<
    蛇足だが、列のコーディングは全射ではない。
    定義により、コーディングを素因数分解したときの指数は必ず正のものが並んだ後にずっと 0 が続くという形になるので、例えば &m<\sp<2><2> \cdot; \sp<3><0> \cdot; \sp<5><1> = 20> はどんな列のコーディングにもならない。
    しかし、上で構成した &m<\op|ord|<len>> は全域関数なので、このような列のコーディングにならない数に対しても値は返され、実際 &m<\op|ord|<len> (20) = 1> である。
    この値に意味はないが、かと言って今後の理論でこれが問題になることもないので、特に気にしないでおく。
  >
  \p<
    さて話を戻して、列のコーディングから各要素を取得するのも原始再帰的にできる。
  >
  \thm|type="prp",id="at"|<
    \p<
      全域関数 &m<@: \sp<\bb<N>><2> \to; \bb<N>> であって、任意の数 &m<\sb<x><0>, \cdots;, \sb<x><k - 1>, y \in; \bb<N>> に対し、&m<y `< k> ならば、
      &mb<
        \langle; \sb<x><0>, \cdots;, \sb<x><k - 1> \rangle; \atsym|bin|; y = \sb<x><y>
      >
      を満たすものが、原始再帰的な関数として存在する。
    >
  >
  \prf<
    \p<
      &m<s \atsym|bin|; y> が &m<s> を素因数分解したときの &m<\op<pr> (y)> の指数から 1 をひいた数になるようにすれば良い。
      &m<s> における &m<\op<pr> (y)> の指数を得るには、&m<\op<pr> (y) \sp<><1>>, &m<\op<pr> (y) \sp<><2>>, &m<\cdots;> が順に &m<s> をわり切るか調べていけば良い。
      したがって &m<@> は、
      &mb<
        s \atsym|bin|; y \coloneqq; (\bar<\rm<`m>> t `< s. \srel; \op<pr> (y) \sp<><t + 1> \nmid; s) \o|bin|<∸> 1
      >
      と定義すれば良い。
      \mref|type="thm",ref="pr"|; によって &m<\op|ord|<pr>> は原始再帰的だから、この関数も原始再帰的である。
    >
  >
  \p<
    さて以上により、自然数の列を 1 つの自然数にコーディングしたり逆にデコードしたりする操作を原始再帰的に行えることが分かった。
    そのため、我々は最初から多価関数や多項関係を考えてきたが、実は 1 価関数や 1 項関係だけを考えれば十分だったことになる。
    この考察を定理の形でまとめておこう。
  >
  \thm|type="thm",id="unary"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> に対して、部分関数 &m<\tilde<f>: \bb<N> \dot<\to;> \bb<N>> を
      &mb<
        \tilde<f> (s) \coloneqq; f (s \atsym|bin|; 0, \cdots;, s \atsym|bin|; k - 1)
      >
      で定める。
      すると、&m<f> が原始再帰的であることと &m<\tilde<f>> が原始再帰的であることは同値である。
    >
  >
  \prf<
    \p<
      まず、&m<f> が原始再帰的であると仮定する。
      \mref|type="thm",ref="at"|; により &m<@> は原始再帰的であったから、&m<\tilde<f>> の上記の定義から &m<\tilde<f>> が原始再帰的であることが分かる。
    >
    \p<
      逆に、&m<\tilde<f>> が原始再帰的であると仮定する。
      すると、&m<f> が
      &mb<
        f (\sb<x><0>, \cdots;, \sb<x><k - 1>) = \tilde<f> (\langle; \sb<x><0>, \cdots;, \sb<x><k - 1> \rangle;)
      >
      と書けることに注目すれば、\mref|type="thm",ref="coding"|; により &m<\langle; \hyphen; \rangle;> は原始再帰的であったから、&m<f> も原始再帰的であることが分かる。
    >
  >
  \p<
    これにより、以降は 1 価関数や 1 項関係に対してだけ理論を構築することにして、多価関数や多項関係を扱う必要が生じたときは上記の方法によって 1 価関数や 1 項関係に変換することにしてしまっても良い。
    ただ、関数や関係が多価であることによって議論が大幅に複雑になるわけでもないので、今後も変わらず多価関数や多項関係を扱うことにする。
  >
  \p<
    これで原始再帰関数の理論は一旦終わりとする。
    次回からは、一般再帰関数の理論を展開していくことにする。
  >
  \h1<参考文献>
  \ol<
    \li|id="ectx"|<H. B. Enderton (2011)『Computability Theory』Academic Press>
  >

>