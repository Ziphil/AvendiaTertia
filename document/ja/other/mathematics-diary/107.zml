\zml?|version="1.1"|;
\xml?|version="1.0",encoding="UTF-8"|;


\page<
  \name<合成の計算可能性>
  \use-math|prefix="10"|;

  \h1<日記 (2026 年 1 月 16 日)>
  \p<
    今回からは、どのような関数が計算可能なのかをより具体的に見ていく。
    しばらくの目標は、全ての一般再帰関数が計算可能であることを示すことである。
  >
  \p<
    本題に入る前に、プログラムを見やすくするための記法を導入しておこう。
    &m<\tt<forward>> 命令や &m<\tt<backward>> 命令は、ポインタの移動先をその命令自身から何個後もしくは前にするかを引数にとる。
    例えば、&m<\tt<forward> \srel; 3> はポインタを 3 つ後ろに進める。
    そのため、これらの命令の実行後にポインタがどこに飛ぶかを確認するには、引数の数の分だけ数えながら目で追う必要があり、若干分かりづらい。
    そこで、命令にラベルを付けておいて、&m<\tt<forward>> や &m<\tt<backward>> の引数にそのラベルを書いてしまうことにする。
    例えば、&m<\tt<backward> \srel; \rm<A>> と書いてあったら、A とラベル付けされた命令にポインタを飛ばすことを意味する。
    もし A とラベル付けされた命令が &m<\tt<backward> \srel; \rm<A>> の 3 つ前にあるのであれば、これは &m<\tt<backward> \srel; 3> と書いてあったことにするわけである。
    また、書かれているプログラムの最後の命令のちょうど次の位置にポインタを飛ばす &m<\tt<forward>> 命令のことを、単に &m<\tt|fun|<end>> と書いてしまうことにする。
    例えば、もし &m<\tt|fun|<end>> の後ろに命令が 2 つ書かれているのであれば、これは &m<\tt<forward> \srel; 3> と書いてあったことにするわけである。
    このような記法を用いれば、前回で恒等関数を計算するプログラムとして挙げた
    &mb<
      \array|align="l"|<
        \c<\tt<dec> \srel; 0> \br;
        \c<\tt<forward> \srel; 3> \br;
        \c<\tt<inc> \srel; 1> \br;
        \c<\tt<backward> \srel; 3>
      >
    >
    というプログラムは、
    &mb<
      \array|align="rl"|<
        \c<\rm<A>:> \c<\tt<dec> \srel; 0> \br;
        \c; \c<\tt|fun|<end>> \br;
        \c; \c<\tt<inc> \srel; 1> \br;
        \c; \c<\tt<backward> \srel; \rm<A>>
      >
    >
    と書くことができる。
    こちらの方が見やすいので、以降は適宜これらの省略記法を用いることにする。
    ここで注意しておくが、あくまでこれは (メタ視点での) 省略記法であり、プログラムの定義を拡張したわけではない。
  >
  \p<
    ところで、このプログラムは 0 番目のレジスタの値を 1 番目のレジスタに移すものであった。
    このようなプログラムは大変便利なので、名前をつけておくことにしよう。
    より一般化して、相異なる自然数 &m<r, s> に対して、&m<r> 番目のレジスタの値を &m<s> 番目に移すプログラム
    &mb<
      \array|align="rl"|<
        \c<\rm<A>:> \c<\tt<dec> \srel; r> \br;
        \c; \c<\tt|fun|<end>> \br;
        \c; \c<\tt<inc> \srel; s> \br;
        \c; \c<\tt<backward> \srel; \rm<A>>
      >
    >
    のことを、以降は &m<\rm<move> \srel; r \to; s> と書くことにする。
    なお、このプログラムは &m<r> 番目と &m<s> 番目以外のレジスタの値は一切変化させないことにも注目しておきたい。
  >
  \p<
    では本題に移るが、まずは初期関数が全て計算可能であることを示す。
  >
  \thm|type="prp",id="init"|<
    \p<
      原始再帰関数の初期関数 &m<\op|ord|<zero>: \sp<\bb<N>><0> \to; \bb<N>>, &m<\op|ord|<succ>: \sp<\bb<N>><1> \to; \bb<N>>, &m<\sbsp<\op|ord|<proj>><i><k>: \sp<\bb<N>><k> \to; \bb<N> \srel; (0 \leq; i `< k)> は全て計算可能である。
    >
  >
  \prf<
    \p<
      各関数を計算するプログラムを構成すれば良い。
      まず、&m<\op|ord|<zero>> を計算するプログラムとは、レジスタが &m<(0, \cdots;)> の状態で実行すると 0 番目のレジスタの値が 0 になるようなものであるが、0 番目のレジスタは最初から 0 なので、何もしないプログラムがこれに該当する。
      すなわち、&m<\op|ord|<zero>> は空の (長さ 0 の) プログラムによって計算されるから、計算可能である。
    >
    \p<
      &m<\op|ord|<succ>> を計算するプログラムとは、任意の &m<x \in; \bb<N>> に対して、レジスタが &m<(x, 0, \cdots;)> の状態で実行すると 1 番目のレジスタの値が &m<x + 1> になるようなものである。
      これを実現するには、0 番目のレジスタの値を 1 番目に移した後に 1 番目のレジスタの値を 1 だけ増やせば良い。
      したがって、&m<\op|ord|<succ>> を計算するプログラムとして &m<(\rm<move> \srel; 0 \to; 1, \tt<inc> \srel; 1)> が考えられる。
      よって、&m<\op|ord|<succ>> は計算可能である。
    >
    \p<
      &m<\sbsp<\op|ord|<proj>><i><k>\srel; (0 \leq; i `< k)> を計算するプログラムとは、任意の &m<\vec<x> \in; \sp<\bb<N>><k>> に対して、レジスタが &m<(\sb<x><0>, \cdots;, \sb<x><k - 1>, 0, \cdots;)> の状態で実行すると &m<k> 番目のレジスタの値が &m<\sb<x><i>> になるようなものである。
      これを実現するには、&m<i> 番目のレジスタの値を &m<k> 番目に移せば良い。
      したがって、&m<\sbsp<\op|ord|<proj>><i><k>> を計算するプログラムとして &m<\rm<move> \srel; i \to; k> そのものが考えられる。
      よって、&m<\sbsp<\op|ord|<proj>><i><k>> は計算可能である。
    >
  >
  \p<
    続いて、計算可能性が合成で閉じていることを示したい。
    そのためには、合成前の関数のプログラムを使って合成後の関数のプログラムを構成すれば良い。
    それを実現するための基本的なアイデアは合成前の関数のプログラムを逐次実行することであるが、これには細かな問題がある。
  >
  \p<
    例えば、関数 &m<\sb<f><0>, \sb<f><1>: \bb<N> \to; \bb<N>> と関数 &m<g: \sp<\bb<N>><2> \to; \bb<N>> の合成 &m<h: \bb<N> \to; \bb<N>> を考える。
    &m<\sb<f><0>, \sb<f><1>, g> を計算するプログラムがそれぞれ &m<\sb<\scr<F>><0>, \sb<\scr<F>><1>, \scr<G>> として与えられているとする。
    さて、
    &mb<
      h (x) = g (\sb<f><0> (x), \sb<f><1> (x))
    >
    であるわけだから、これを計算したければ、レジスタに入力された &m<x> に対して &m<\sb<\scr<F>><0>> と &m<\sb<\scr<F>><1>> を実行して &m<\sb<f><0> (x), \sb<f><1> (x)> を得て、それに対してさらに &m<\scr<G>> を実行すれば良さそうである。
    しかし、これはナイーブにはうまくいかない。
    レジスタを &m<(x, 0, \cdots;)> で初期化して &m<\sb<\scr<F>><0>> を実行すると、1 番目のレジスタの値は確かに &m<\sb<f><0> (x)> になるが、それ以外のレジスタの値は保証されない。
    そのため、0 番目のレジスタがもはや &m<x> ではなくなっている可能性があり、その場合この後で &m<\sb<\scr<F>><1>> を実行しても &m<\sb<f><1> (x)> は得られない。
    さらに、仮に 0 番目のレジスタが &m<x> のままであったとしても、2 番目以降のレジスタに 0 以外の数値が残っている可能性もある。
    &m<\sb<\scr<F>><1>> はあくまでレジスタが &m<(x, 0, \cdots;)> の状態で実行すると 1 番目のレジスタの値が &m<\sb<f><1> (x)> になることを保証しているだけなので、2 番目以降のレジスタに 0 以外の値が格納されている場合にどのような結果になるかは分からない。
  >
  \p<
    したがって、プログラムをうまく合成するためには、入力から特定の出力が得られること以上に、特定の範囲のレジスタの値を一切変化させないことや、入力以外のレジスタの値に動作が依存しないことなども保証されている必要がある。
    また、プログラムの入力と出力がそれぞれ 0 番目から &m<k - 1> 番目までのレジスタと &m<k> 番目のレジスタに固定されているのも不便なので、これも柔軟に変更できるようにしておきたい。
    そこで、プログラムが関数を計算することの定義を、以下のように拡張する。
  >
  \thm|type="def",id="prescomp"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> とプログラム &m<\scr<F>> をとる。
      さらに、相異なる自然数 &m<\sb<r><0>, \cdots;, \sb<r><k - 1>> および自然数 &m<s, t> をとる。
      任意の &m<\vec<x> \in; \sp<\bb<N>><k>> に対して、各 &m<i \srel; (0 \leq; i `< k)> に対して &m<\sb<r><i>> 番目のレジスタの値が &m<\sb<x><i>> である状態で &m<\scr<F>> を実行すると、次の 2 条件がともに成り立つとする。
    >
    \ul<
      \li*<
        &m<f (\vec<x>)> が定義されているならば、&m<\scr<F>> の実行後に &m<s> 番目のレジスタの値が &m<f (\vec<x>)> になった状態で正常終了する。
        さらに、&m<\scr<F>> の実行中に &m<0> 番目から &m<t - 1> 番目までであって &m<s> 番目を除くレジスタの値は全て一切変化しない。
      >
      \li*<
        &m<f (\vec<x>)> が定義されていないならば、&m<\scr<F>> の実行は永遠に終了しない。
      >
    >
    \p<
      このとき、&m<\scr<F>> は &m<\sb<r><0>, \cdots;, \sb<r><k - 1>> から &m<s> へ &m<t> を保ちながら &m<f> を \def<計算する\fl<compute>> という。
    >
  >
  \p<
    この定義の条件はなかなか厳しいが、ある関数を通常の意味で計算するプログラムからは、常に上記の条件を満たすプログラムを構成することができる。
    これを示すために、まずは便利なプログラムをいくつか用意しよう。
  >
  \p<
    自然数 &m<r> に対し、次のプログラムを考える。
    &mb<
      \array|align="rl"|<
        \c<\rm<A>:> \c<\tt<dec> \srel; r> \br;
        \c; \c<\tt|fun|<end>> \br;
        \c; \c<\tt<backward> \srel; \rm<A>>
      >
    >
    これは、&m<r> 番目のレジスタの値を減らし続けて、それが 0 になったら終了するプログラムである。
    つまり、&m<r> 番目のレジスタの値を 0 にリセットするわけである。
    このプログラムは、以降 &m<\rm<clear> \srel; r> と書くことにする。
  >
  \p<
    また、相異なる自然数 &m<r, s, t> に対し、次のプログラムも考えよう。
    &mb<
      \array|align="rl"|<
        \c; \c<\rm<clear> \srel; s> \br;
        \c; \c<\rm<move> \srel; r \to; t> \br;
        \c<\rm<A>:> \c<\tt<dec> \srel; t> \br;
        \c; \c<\tt<end>> \br;
        \c; \c<\tt<inc> \srel; r> \br;
        \c; \c<\tt<inc> \srel; s> \br;
        \c; \c<\tt<backward> \srel; \rm<A>> \br;
      >
    >
    先に言ってしまうとこれは、&m<r> 番目のレジスタの値を &m<s> 番目のレジスタにコピーするプログラムである。
    この際に、&m<t> 番目のレジスタを作業領域として用いる。
    プログラムの動きを順番に追ってみよう。
    まず最初の 2 行で、&m<s> 番目のレジスタを 0 にリセットし、&m<r> 番目の値を一度 &m<t> 番目に移す。
    この後の 5 行では、この &m<t> 番目の値を減らしながら &m<r> 番目と &m<s> 番目の値を増やす。
    これにより、&m<r> 番目と &m<s> 番目の値が減らし始める前の &m<t> 番目の値と等しくなったところで、&m<t> 番目の値が 0 になって終了する。
    これで、&m<r> 番目と &m<s> 番目の値がともに最初の &m<r> 番目の値と等しくなるので、結果的に &m<r> 番目の値を &m<s> 番目にコピーしたことになる。
    このプログラムは、以降 &m<\rm<copy> \srel; r \to; s, t> と書くことにする。
  >
  \p<
    以上の準備のもと、ある関数を計算するプログラムから\mref|type="thm",ref="prescomp"|; の条件を満たすプログラムを構成しよう。
  >
  \thm|type="prp"|<
    \p<
       部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> とプログラム &m<\scr<F>> をとる。
       さらに、相異なる自然数 &m<\sb<r><0>, \cdots;, \sb<r><k - 1>> および自然数 &m<s, t> をとる。
       &m<\scr<F>> が &m<f> を通常の意味で計算するならば、あるプログラム &m<\scr<F> `[\sb<r><0>, \cdots;, \sb<r><k - 1> \to; s \mid; t`]> が存在して、これは &m<\sb<r><0>, \cdots;, \sb<r><k - 1>> から &m<s> へ &m<t> を保ちながら &m<f> を計算する。
    >
  >
  \prf<
    \p<
      まず、
      &mb<
        m \coloneqq; \max; `{ r \mid; &raw<&m<\scr<F>> に &m<\tt<inc> \srel; r> もしくは &m<\tt<dec> \srel; r> が属する>`}
      >
      とおく。
      レジスタの値を参照したり操作したりするのは &m<\tt<inc>> 命令と &m<\tt<dec>> 命令だけなので、&m<\scr<F>> は &m<m> 番目以前のレジスタしか参照せず、&m<\scr<F>> の動作は &m<m> 番目より後のレジスタの値には依存しない。 
      また、
      &mb<
        w \coloneqq; \max; (\sb<r><0>, \cdots;, \sb<r><k - 1>, t)
      >
      とおき、&m<\scr<F>> に属する &m<\tt<inc>> 命令もしくは &m<\tt<dec>> 命令が参照する全てのレジスタ番号に &m<w> を加えて得られるプログラムを &m<\sb<\scr<F>><+ w>> と書くことにする。
      すると、&m<\sb<\scr<F>><+ w>> は &m<w> 番目から &m<w + m> 番目までのレジスタしか参照しない。
      したがって、&m<\sb<\scr<F>><+ w>> の動作は &m<w + m> 番目より後のレジスタの値には依存しないし、&m<\sb<\scr<F>><+ w>> の実行中に &m<w> 番目より前のレジスタの値が変化することはない。
    >
    \p<
      ここで、以下のプログラムを &m<\tilde<\scr<F>>> とする。
      &mb<
        \array|align="rl"|<
          \c; \c<\rm<copy> \srel; \sb<r><0> \to; w, w + 1> \br;
          \c; \c<\rm<copy> \srel; \sb<r><1> \to; w + 1, w + 2> \br;
          \c; \c<\quad; \vdots;> \br;
          \c; \c<\rm<copy> \srel; \sb<r><k - 1> \to; w + k - 1, w + k> \br;
          \c; \c<\rm<clear> \srel; w + k> \br;
          \c; \c<\rm<clear> \srel; w + k + 1> \br;
          \c; \c<\quad; \vdots;> \br;
          \c; \c<\rm<clear> \srel; w + \max; (m, k)> \br;
          \c; \c<\sb<\scr<F>><+ w>> \br;
          \c; \c<\rm<move> \srel; w + k \to; s> \br;
        >
      >
      &m<\sb<r><0>, \cdots;, \sb<r><k - 1>> 番目のレジスタの値がそれぞれ &m<\sb<x><0>, \cdots;, \sb<x><k - 1>> である状態から、この &m<\tilde<\scr<F>>> の動作を追ってみよう。
      まず、これらのレジスタの値が &m<w> 番目から &m<w + k - 1> 番目までに順にコピーされる。
      すなわち、&m<w, \cdots;, w + k - 1> 番目のレジスタの値がそれぞれ &m<\sb<x><0>, \cdots;, \sb<x><k - 1>> になる。
      続いて、&m<w + k> 番目から &m<w + \max; (m, k)> 番目までのレジスタが 0 にリセットされる。
      これにより、レジスタ番号が &m<w> だけズレていることを除けば、&m<\scr<F>> が &m<f (\vec<x>)> を計算するときと同じ状況になっている。
      そのため、この後で &m<\sb<\scr<F>><+ w>> が実行されると、もし &m<f (\vec<x>)> が定義されているのであれば、これで &m<w + k> 番目のレジスタに &m<f (\vec<x>)> が格納されるはずである。
      最後に、この &m<w + k> 番目のレジスタの値が &m<s> 番目のレジスタに移されるから、&m<s> 番目のレジスタの値は &m<f (\vec<x>)> になる。
      また、もし &m<f (\vec<x>)> が定義されていないならば、&m<\sb<\scr<F>><+ w>> の実行は永遠に終了しないはずなので、上記の &m<\tilde<\scr<F>>> も永遠に終了しない。
      以上により、この &m<\tilde<\scr<F>>> が定理で主張されている &m<\scr<F> `[\sb<r><0>, \cdots;, \sb<r><k - 1> \to; s \mid; t`]> である。
    >
  >
  \p<
    この定理を利用すれば、計算可能性が関数の合成で閉じていることが簡単に示せる。
  >
  \thm|type="prp",id="comp"|<
    \p<
      部分関数 &m<\sb<f><0>, \cdots;, \sb<f><l - 1>: \sp<\bb<N>><k> \dot<\to;> \bb<N>> および部分関数 &m<g: \sp<\bb<N>><l> \dot<\to;> \bb<N>> に対し、これらから合成で得られる部分関数を &m<h: \sp<\bb<N>><k> \dot<\to;> \bb<N>> とする。
      &m<\sb<f><0>, \cdots;, \sb<f><l - 1>, g> が全て計算可能ならば、&m<h> も計算可能である。
    >
  >
  \prf<
    \p<
      &m<\sb<f><0>, \cdots;, \sb<f><l - 1>, g> を計算するプログラムをそれぞれ &m<\sb<\scr<F>><0>, \cdots;, \sb<\scr<F>><l - 1>, \scr<G>> とする。
      このとき、次のプログラムを &m<\scr<H>> とする。
      &mb<
        \array|align="l"|<
          \c<\sb<\scr<F>><0> `[ 0, \cdots;, k - 1 \to; k \mid; k `]> \br;
          \c<\sb<\scr<F>><1> `[ 0, \cdots;, k - 1 \to; k + 1 \mid; k + 1 `]> \br;
          \c<\quad; \vdots;> \br;
          \c<\sb<\scr<F>><l - 1> `[ 0, \cdots;, k - 1 \to; k + l - 1 \mid; k + l - 1 `]> \br;
          \c<\scr<G> `[ k, \cdots;, k + l - 1 \to; k \mid; 0 `]> \br;
        >
      >
      レジスタが &m<(\sb<x><0>, \cdots;, \sb<x><k - 1>, 0, \cdots;)> である状態から &m<\scr<H>> の動作を追おう。
      まず、&m<\sb<\scr<F>><0> `[ 0, \cdots;, k - 1 \to; k \mid; k `]> が実行されると、&m<\sb<f><0> (\vec<x>)> が定義されているなら、&m<k> 番目のレジスタにその &m<\sb<f><0> (\vec<x>)> が格納される。
      このとき、&m<k> 番目より前のレジスタの値は変化しないから、 &m<0, \cdots;, k - 1> 番目のレジスタの値は &m<\sb<x><0>, \cdots;, \sb<x><k - 1>> のままである。
      したがって、次に &m<\sb<\scr<F>><1> `[ 0, \cdots;, k - 1 \to; k + 1 \mid; k + 1 `]> が実行されると、&m<\sb<f><1> (\vec<x>)> が定義されているなら、&m<k + 1> 番目のレジスタに &m<\sb<f><1> (\vec<x>)> が格納される。
      これを続けると、&m<\sb<\scr<F>><l - 1> `[ 0, \cdots;, k - 1 \to; k + l - 1 \mid; k + l - 1 `]> が実行された時点で、&m<\sb<f><0> (\vec<x>), \cdots;, \sb<f><l - 1> (\vec<x>)> が全て定義されているのであれば、&m<0, \cdots;, k - 1, k, \cdots;, k + l - 1> 番目のレジスタの値はそれぞれ &m<\sb<x><0>, \cdots;, \sb<x><k - 1>, \sb<f><0> (\vec<x>), \cdots;, \sb<f><l - 1> (\vec<x>)> になっているはずである。
      そのため、ここで &m<\scr<G> `[ k, \cdots;, k + l - 1 \to; k \mid; 0 `]> が実行されると、&m<g (\sb<f><0> (\vec<x>), \cdots;, \sb<f><l - 1> (\vec<x>))> が定義されているなら、&m<k> 番目のレジスタに &m<g (\sb<f><0> (\vec<x>), \cdots;, \sb<f><l - 1> (\vec<x>))> すなわち &m<h (\vec<x>)> が格納される。
    >
    \p<
      仮に &m<\sb<f><0> (\vec<x>), \cdots;, \sb<f><l - 1> (\vec<x>)> のうちいずれかが定義されないなら、それに対応する &m<\sb<\scr<F>><i> `[  0, \cdots;, k - 1 \to; k + i - 1 \mid; k + i - 1 `]> の実行は終了しないので、上記 &m<\scr<H>> の実行も終了しない。
      これらが全て定義されていても &m<g (\sb<f><0> (\vec<x>), \cdots;, \sb<f><l - 1> (\vec<x>))> が定義されないなら、&m<\scr<G> `[ k, \cdots;, k + l - 1 \to; k \mid; 0 `]> の実行は終了せず、やはり上記 &m<\scr<H>> の実行も終了しない。
    >
    \p<
      以上により、上記 &m<\scr<H>> は &m<h> を計算するプログラムの定義を満たしている。
      したがって、&m<h> は計算可能である。
    >
  >
  \p<
    次回は、計算可能性が原始再帰と最小化でも閉じていることを示し、全ての一般再帰関数が計算可能であることを示す。
  >
  \h1<参考文献>
  \ol<
    \li|id="ectx"|<H. B. Enderton (2011)『Computability Theory』Academic Press>
  >

>