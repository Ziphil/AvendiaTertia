\zml?|version="1.1"|;
\xml?|version="1.0",encoding="UTF-8"|;


\page<
  \name<レジスタマシン>
  \use-math|prefix="10"|;

  \h1<日記 (2026 年 1 月 15 日)>
  \p<
    今回は、どのような関数が計算可能なのかをより具体的に見ていく。
    しばらくの目標は、全ての一般再帰関数が計算可能であることを示すことである。
  >
  \p<
    本題に入る前に、プログラムを見やすくするための記法を導入しておこう。
    &m<\tt<forward>> 命令や &m<\tt<backward>> 命令は、ポインタの移動先をその命令自身から何個後もしくは前にするかを引数にとる。
    例えば、&m<\tt|fun|<forward> 3> はポインタを 3 つ後ろに進める。
    そのため、これらの命令の実行後にポインタがどこに飛ぶかを確認するには、引数の数の分だけ数えながら目で追う必要があり、若干分かりづらい。
    そこで、命令にラベルを付けておいて、&m<\tt<forward>> や &m<\tt<backward>> の引数にそのラベルを書いてしまうことにする。
    例えば、&m<\tt|fun|<backward> \rm<A>> と書いてあったら、A とラベル付けされた命令にポインタを飛ばすことを意味する。
    もし A とラベル付けされた命令が &m<\tt|fun|<backward> \rm<A>> の 3 つ前にあるのであれば、これは &m<\tt|fun|<backward> 3> と書いてあったことにするわけである。
    また、書かれているプログラムの最後の命令のちょうど次の位置にポインタを飛ばす &m<\tt<forward>> 命令のことを、単に &m<\tt|fun|<end>> と書いてしまうことにする。
    例えば、もし &m<\tt|fun|<end>> の後ろに命令が 2 つ書かれているのであれば、これは &m<\tt|fun|<forward> 3> と書いてあったことにするわけである。
    このような記法を用いれば、前回で恒等関数を計算するプログラムとして挙げた
    &mb<
      \array|align="l"|<
        \c<\tt|fun|<dec> 0> \br;
        \c<\tt|fun|<forward> 3> \br;
        \c<\tt|fun|<inc> 1> \br;
        \c<\tt|fun|<backward> 3>
      >
    >
    というプログラムは、
    &mb<
      \array|align="rl"|<
        \c<\rm<A>:> \c<\tt|fun|<dec> 0> \br;
        \c; \c<\tt|fun|<end>> \br;
        \c; \c<\tt|fun|<inc> 1> \br;
        \c; \c<\tt|fun|<backward> \rm<A>>
      >
    >
    と書くことができる。
    こちらの方が見やすいので、以降は適宜これらの省略記法を用いることにする。
  >
  \p<
    ところで、このプログラムは 0 番目のレジスタの値を 1 番目のレジスタに移すものであった。
    このようなプログラムは大変便利なので、名前をつけておくことにしよう。
    より一般化して、相異なる自然数 &m<r, s> に対して、&m<r> 番目のレジスタの値を &m<s> 番目に移すプログラムを、
    &mb<
      \array|align="rl"|<
        \c<\rm<A>:> \c<\tt|fun|<dec> r> \br;
        \c; \c<\tt|fun|<end>> \br;
        \c; \c<\tt|fun|<inc> s> \br;
        \c; \c<\tt|fun|<backward> \rm<A>>
      >
    >
    のことを、以降は &m<\op<move> r \to; s> と書くことにする。
    なお、このプログラムは &m<r> 番目と &m<s> 番目以外のレジスタの値は一切変化させないことにも注意しておきたい。
  >
  \p<
    では本題に移るが、まずは初期関数が全て計算可能であることを示す。
  >
  \thm|type="def"|<
    \p<
      原始再帰関数の初期関数 &m<\op|ord|<zero>: \sp<\bb<N>><0> \to; \bb<N>>, &m<\op|ord|<succ>: \sp<\bb<N>><1> \to; \bb<N>>, &m<\sbsp<\op|ord|<proj>><i><k>: \sp<\bb<N>><k> \to; \bb<N> \srel; (0 \leq; i `< k)> は全て計算可能である。
    >
  >
  \prf<
    \p<
      各関数を計算するプログラムを構成すれば良い。
      まず、&m<\op|ord|<zero>> を計算するプログラムとは、レジスタが &m<(0, \cdots;)> の状態で実行すると 0 番目のレジスタの値が 0 になるようなものであるが、0 番目のレジスタは最初から 0 なので何もしないプログラムがこれに該当する。
      すなわち、&m<\op|ord|<zero>> は空の (長さ 0 の) プログラムによって計算されるから、計算可能である。
    >
    \p<
      &m<\op|ord|<succ>> を計算するプログラムとは、任意の &m<x \in; \bb<N>> に対して、レジスタが &m<(x, 0, \cdots;)> の状態で実行すると 1 番目のレジスタの値が &m<x + 1> になるようなものである。
      これを実現するには、0 番目のレジスタの値を 1 番目に移した後に 1 番目のレジスタの値を 1 だけ増やせば良い。
      したがって、&m<\op|ord|<succ>> を計算するプログラムとして &m<(\op<move> 0 \to; 1, \op<inc> 1)> が考えられる。
      よって、&m<\op|ord|<succ>> は計算可能である。
    >
    \p<
      &m<\sbsp<\op|ord|<proj>><i><k>\srel; (0 \leq; i `< k)> を計算するプログラムとは、任意の &m<\vec<x> \in; \sp<\bb<N>><k>> に対して、レジスタが &m<(\sb<x><0>, \cdots;, \sb<x><k - 1>, 0, \cdots;)> の状態で実行すると &m<k> 番目のレジスタの値が &m<\sb<x><i>> になるようなものである。
      これを実現するには、&m<i> 番目のレジスタの値を &m<k> 番目に移せば良い。
      したがって、&m<\sbsp<\op|ord|<proj>><i><k>> を計算するプログラムとして &m<\op<move> i \to; k> そのものが考えられる。
      よって、&m<\sbsp<\op|ord|<proj>><i><k>> は計算可能である。
    >
  >
  \p<
    続いて、計算可能性が合成で閉じていることを示したい。
    そのためには、合成前の関数のプログラムを使って合成後の関数のプログラムを構成すれば良い。
    それを実現するための基本的なアイデアは合成前の関数のプログラムを逐次実行することであるが、これには細かな問題がある。
  >
  \p<
    例えば、部分関数 &m<\sb<f><0>, \sb<f><1>: \bb<N> \dot<\to;> \bb<N>> と部分関数 &m<g: \sp<\bb<N>><2> \dot<\to;> \bb<N>> の合成 &m<h: \bb<N> \dot<\to;> \bb<N>> を考える。
    &m<\sb<f><0>, \sb<f><1>, g> を計算するプログラムがそれぞれ &m<\sb<\scr<F>><0>, \sb<\scr<F>><1>, \scr<G>> として与えられているとする。
    さて、
    &mb<
      h (x) = g (\sb<f><0> (x), \sb<f><1> (x))
    >
    であるわけだから、これを計算したければ、レジスタに入力された &m<x> に対して &m<\sb<\scr<F>><0>> と &m<\sb<\scr<F>><1>> を実行して &m<\sb<f><0> (x), \sb<f><1> (x)> を得て、それに対してさらに &m<\scr<G>> を実行すれば良さそうである。
    しかし、これはナイーブにはうまくいかない。
    レジスタを &m<(x, 0, \cdots;)> で初期化して &m<\sb<\scr<F>><0>> を実行すると、1 番目のレジスタの値は確かに &m<\sb<f><0> (x)> になるが、それ以外のレジスタの値は保証されない。
    そのため、0 番目のレジスタがもはや &m<x> ではなくなっている可能性があり、その場合この後で &m<\sb<\scr<F>><1>> を実行しても &m<\sb<f><1> (x)> は得られない。
    さらに、仮に 0 番目のレジスタが &m<x> のままであったとしても、2 番目以降のレジスタに 0 以外の数値が残っている可能性もある。
    &m<\sb<\scr<F>><1>> はあくまでレジスタが &m<(x, 0, \cdots;)> の状態で実行すると 1 番目のレジスタの値が &m<\sb<f><1> (x)> になることを保証しているだけなので、2 番目以降のレジスタに 0 以外の値が格納されている場合にどのような結果になるかは分からない。
  >
  \p<
    したがって、プログラムをうまく合成するためには、入力から特定の出力が得られること以上に、特定の範囲のレジスタの値を一切変化させないことも保証されている必要がある。
    また、プログラムの入力と出力がそれぞれ 0 番目から &m<k - 1> 番目までのレジスタと &m<k> 番目のレジスタに固定されているのも不便なので、これも柔軟に変更できるようにしておきたい。
    そこで、プログラムが関数を計算することの定義を、以下のように拡張する。
  >
  \thm|type="def"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> とプログラム &m<\scr<F>> をとる。
      さらに、相異なる自然数 &m<\sb<r><0>, \cdots;, \sb<r><k - 1>> および自然数 &m<s, t> をとる。
      任意の &m<\vec<x> \in; \sp<\bb<N>><k>> に対して、各 &m<i \srel; (0 \leq; i `< k)> に対して &m<\sb<r><i>> 番目のレジスタの値が &m<\sb<x><i>> である状態で &m<\scr<F>> を実行すると、次の 2 条件がともに成り立つとする。
    >
    \ul<
      \li*<
        &m<f (\vec<x>)> が定義されているならば、&m<\scr<F>> の実行後に &m<s> 番目のレジスタの値が &m<f (\vec<x>)> になった状態で正常終了する。
        さらに、&m<\scr<F>> の実行中に &m<0> 番目から &m<t - 1> 番目までであって &m<s> 番目を除くレジスタの値は全て一切変化しない。
      >
      \li*<
        &m<f (\vec<x>)> が定義されていないならば、&m<\scr<F>> の実行は永遠に終了しない。
      >
    >
    \p<
      このとき、&m<\scr<F>> は &m<\sb<r><0>, \cdots;, \sb<r><k - 1>> から &m<s> へ &m<t> を保ちながら &m<f> を \def<計算する\fl<compute>> という。
    >
  >
  \p<
    この定義の条件はなかなか厳しいが、ある関数を通常の意味で計算するプログラムからは、常に上記の条件を満たすプログラムを構成することができる。
    これを示すために、まずは便利なプログラムをいくつか用意しよう。
  >
  \p<
    自然数 &m<r> に対し、次のプログラムを考える。
    &mb<
      \array|align="rl"|<
        \c<\rm<A>:> \c<\tt|fun|<dec> r> \br;
        \c; \c<\tt|fun|<end>> \br;
        \c; \c<\tt|fun|<backward> \rm<A>>
      >
    >
    これは、&m<r> 番目のレジスタの値を減らし続けて、それが 0 になったら終了するプログラムである。
    つまり、&m<r> 番目のレジスタの値を 0 にリセットするわけである。
    このプログラムは、以降 &m<\op<clear> r> と書くことにする。
  >
  \p<
    また、相異なる自然数 &m<r, s, t> に対し、次のプログラムも考えよう。
    &mb<
      \array|align="rl"|<
        \c; \c<\op<clear> s> \br;
        \c; \c<\op<move> r \to; t> \br;
        \c<\rm<A>:> \c<\tt|fun|<dec> t> \br;
        \c; \c<\tt<end>> \br;
        \c; \c<\tt|fun|<inc> r> \br;
        \c; \c<\tt|fun|<inc> s> \br;
        \c; \c<\tt|fun|<backward> \rm<A>> \br;
      >
    >
    先に言ってしまうとこれは、&m<r> 番目のレジスタの値を &m<s> 番目のレジスタにコピーするプログラムである。
    この際に、&m<t> 番目のレジスタを作業領域として用いる。
    プログラムの動きを順番に追ってみよう。
    まず最初の 2 行で、&m<s> 番目のレジスタを 0 にリセットし、&m<r> 番目の値を一度 &m<t> 番目に移す。
    この後の 5 行では、この &m<t> 番目の値を減らしながら &m<r> 番目と &m<s> 番目の値を増やす。
    これにより、&m<r> 番目と &m<s> 番目の値が減らし始める前の &m<t> 番目の値と等しくなったところで、&m<t> 番目の値が 0 になって終了する。
    これで、&m<r> 番目と &m<s> 番目の値がともに最初の &m<r> 番目の値と等しくなるので、結果的に &m<r> 番目の値を &m<s> 番目にコピーしたことになる。
    このプログラムは、以降 &m<\op<copy> r \to; s `; t> と書くことにする。
  >
  \thm|type="thm"|<
    \p<
       部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> とプログラム &m<\scr<F>> をとる。
       さらに、相異なる自然数 &m<\sb<r><0>, \cdots;, \sb<r><k - 1>> および自然数 &m<s, t> をとる。
       &m<\scr<F>> が &m<f> を通常の意味で計算するならば、あるプログラム &m<\tilde<\scr<F>>> が存在して、 &m<\tilde<\scr<F>>> は &m<\sb<r><0>, \cdots;, \sb<r><k - 1>> から &m<s> へ &m<t> を保ちながら &m<f> を計算する。
    >
  >
  \p<
    以降、上記定理中の &m< &m<\tilde<\scr<F>>>> のことを &m<\scr<F> `[\sb<r><0>, \cdots;, \sb<r><k - 1> \to; s `; t`]> と書くことにする。
  >
  \h1<参考文献>
  \ol<
    \li|id="ectx"|<H. B. Enderton (2011)『Computability Theory』Academic Press>
  >

>