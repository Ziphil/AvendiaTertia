\zml?|version="1.1"|;
\xml?|version="1.0",encoding="UTF-8"|;


\page<
  \name<一般再帰的ならば計算可能>
  \use-math|prefix="11"|;

  \h1<日記 (2026 年 1 月 19 日)>
  \p<
    前回、計算可能性が合成で閉じたことを示した。
    今回は、原始再帰と最小化でも閉じていることを示し、その結果として全ての一般再帰関数が計算可能であることを示す。
  >
  \p<
    まずは、計算可能性が原始再帰で閉じていることを示そう。
  >
  \thm|type="prp",id="rec"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> および部分関数 &m<g: \sp<\bb<N>><k + 2> \dot<\to;> \bb<N>> に対し、これらから原始再帰で得られる部分関数を &m<h: \sp<\bb<N>><k + 1> \dot<\to;> \bb<N>> とする。
      &m<f, g> がともに計算可能ならば、&m<h> も計算可能である。
    >
  >
  \prf<
    \p<
      &m<f, g> を計算するプログラムをそれぞれ &m<\scr<F>, \scr<G>> とし、次のプログラムを &m<\scr<H>> とする。
      &mb<
        \array|align="rl"|<
          \c; \c<\scr<F> `[ 0, \cdots;, k - 1 \to; k + 1 \mid; k + 3 `]> \br;
          \c<\rm<A>:> \c<\tt<dec> \srel; k> \br;
          \c; \c<\tt<end>> \br;
          \c; \c<\scr<G> `[ 0, \cdots;, k - 1, k + 2, k + 1 \to; k + 1 \mid; k + 3 `]> \br;
          \c; \c<\tt<inc> \srel; k + 2> \br;
          \c; \c<\tt<backward> \srel; \rm<A>> \br;
        >
      >
      これが &m<h> を計算することを示したい。
      そのために、レジスタが &m<(\sb<x><0>, \cdots;, \sb<x><k - 1>, y, 0, \cdots;)> である状態から &m<\scr<H>> を実行したときの動作を考える。
      以下、自然数 &m<t \srel; (0 \leq; t \leq; y)> に対して、以下の主張を帰納法によって示す。
    >
    \ul<
      \li*<
        &m<h (\vec<x>, t)> が定義されるならば、行 &m<\rm<A>> の命令は少なくとも &m<t + 1> 回実行され、&m<t> 回目 (0 から数える) に実行されようとする直前でのレジスタの状態は、
        &mb<
          (\sb<x><0>, \cdots;, \sb<x><k - 1>, y - t, h (\vec<x>, t), t, ?, \cdots;)
        >
        である。
      >
      \li*<
        &m<h (\vec<x>, t)> が定義されないならば、実行は停止しない。
      >
    >
    \p<
      まず &m<t = 0> の場合を示すために、&m<\scr<H>> の動作を初めから追おう。
      &m<h (\vec<x>, 0)> すなわち &m<f (\vec<x>)> が定義されるならば、&m<\scr<F> `[ 0, \cdots;, k - 1 \to; k + 1 \mid; k + 3 `]> が実行されると &m<k + 1> 番目のレジスタの値はその &m<h (\vec<x>, 0)> になり、それ以外の &m<k + 3> 番目より前のレジスタの値は変化しない。
      したがって、この時点でのレジスタの状態は、
      &mb<
        (\sb<x><0>, \cdots;, \sb<x><k - 1>, y, f (\vec<x>), 0, 0, \cdots;)
      >
      であり、この状態で次に行 &m<\rm<A>> が実行される。
      &m<h (\vec<x>, 0)> すなわち &m<f (\vec<x>)> が定義されないならば、 &m<\scr<F> `[ 0, \cdots;, k - 1 \to; k + 1 \mid; k + 3 `]> の実行が終了しないので、&m<\scr<H>> の実行全体も停止しない。
      以上で &m<t = 0> の場合の主張は示された。
    >
    \p<
      続いて帰納ステップのために、ある &m<t' \srel; (0 \leq; t' \leq; y - 1)> について &m<t = t'> のときに主張が成り立つと仮定する。
      まずは、&m<h (\vec<x>, t' + 1)> が定義される場合を考える。
      原始再帰の定義により、
      &mb<
        h (\vec<x>, t' + 1) = g (\vec<x>, t',  h (\vec<x>, t'))
      >
      であるから、&m<h (\vec<x>, t')> と &m<g (\vec<x>, t',  h (\vec<x>, t'))> はともに定義されているはずである。
      すなわち、帰納法の仮定により、&m<t'> 回目の行 &m<\rm<A>> の直前では、レジスタが
      &mb<
        (\sb<x><0>, \cdots;, \sb<x><k - 1>, y - t', h (\vec<x>, t'), t', ?, \cdots;)
      >
      となっている。
      ここで、行 &m<\rm<A>> すなわち &m<\tt<dec> \srel; k> が実行されると、&m<y - t' `> 0> であるから、&m<k> 番目のレジスタの値は &m<y - t' - 1> に更新される。
      続いて &m<\scr<G> `[ 0, \cdots;, k - 1, k + 2, k + 1 \to; k + 1 \mid; k + 3 `]> が実行されるから、&m<k + 1> 番目のレジスタの値が &m<g (\vec<x>, t',  h (\vec<x>, t'))> になる。
      次に &m<\tt<inc> \srel; k + 2> が実行されると、&m<k + 2> 番目のレジスタの値は &m<t' + 1> に更新される。
      そして、&m<\tt<backward> \srel; \rm<A>> が実行され、ポインタは行 &m<\rm<A>> に戻る。
      このときのレジスタの状態は、
      &mb<
        (\sb<x><0>, \cdots;, \sb<x><k - 1>, y - t' - 1, g (\vec<x>, t',  h (\vec<x>, t')), t' + 1, ?, \cdots;)
      >
      である。
      &m<g (\vec<x>, t',  h (\vec<x>, t')) = h (\vec<x>, t' + 1)> であるから、この場合は主張が示された。
    >
    \p<
      &m<h (\vec<x>, t' + 1)> が定義されない場合は、&m<h (\vec<x>, t')> が定義されていないか、それが定義されても &m<g (\vec<x>, t',  h (\vec<x>, t'))> が定義されないかのどちらかである。
      前者の場合は、帰納法の仮定から &m<\scr<H>> 全体の実行は停止しない。
      後者の場合は、&m<t'> 回目の行 &m<\rm<A>> の実行の後で上の議論と同様に &m<\scr<G> `[ 0, \cdots;, k - 1, k + 2, k + 1 \to; k + 1 \mid; k + 3 `]> の実行に移るが、これが停止しない。
      したがって、どちらの場合でも &m<\scr<H>> 全体の実行は停止しない。
      以上で、帰納ステップも示された。
    >
    \p<
      この主張により、&m<h (\vec<x>, y)> が定義されるなら、&m<y> 回目に行 &m<\rm<A>> が実行されようとする直前でのレジスタの状態は、
      &mb<
        (\sb<x><0>, \cdots;, \sb<x><k - 1>, 0, h (\vec<x>, y), y, ?, \cdots;)
      >
      である。
      この状態で行 &m<\rm<A>> すなわち &m<\tt<dec> \srel; k> が実行されると、&m<k> 番目のレジスタの値は &m<0> なのでポインタは直後の行に移り、そこで &m<\scr<H>> の実行は終了し、このときの &m<k + 1> 番目のレジスタの値は &m<h (\vec<x>, y)> である。
      また、&m<h (\vec<x>, y)> が定義されないなら、主張から &m<\scr<H>> の実行は停止しない。
      これで、&m<\scr<H>> が &m<h> を計算することが示された。
    >
  >
  \p<
    さて、これによりまずは原始再帰関数が計算可能であることが分かる。
  >
  \thm|type="thm",id="primreccomp"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> に対し、&m<f> が原始再帰的ならば、&m<f> は計算可能である。
    >
  >
  \prf<
    \p<
      原始再帰的であるとは、初期関数から合成と原始再帰の繰り返しで得られる部分関数であった。
      ところで、\a|href="107.html#init"|<命題 10.1> により初期関数は計算可能であり、\a|href="107.html#comp"|<命題 10.4> と\mref|type="thm",ref="rec"|; により合成と原始再帰で計算可能性は保存される。
      したがって、原始再帰的な部分関数は全て計算可能になる。
    >
  >
  \p<
    続いて、計算可能性が最小化でも閉じていることを示そう。
    なお、これまでの慣習通り、関係が計算可能であるとはその関係の特性関数が計算可能であることをいう。
  >
  \thm|type="prp",id="min"|<
    \p<
      関係 &m<P \subseteq; \sp<\bb<N>><k + 1>> に対し、これから最小化で得られる部分関数を &m<h: \sp<\bb<N>><k> \dot<\to;> \bb<N>> とする。
      &m<P> が計算可能ならば、&m<h> も計算可能である。
    >
  >
  \prf<
    \p<
      関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> を
      &mb<
        \array|align="rcl"|<
          \c<f (\vec<x>, t)> \c<\coloneqq;> \c<1 \dotminus; \sb<\op<ch>><P> (\vec<x>, t)> \br;
          \c; \c<=> \c<\case<
            \c<0> \c<((\vec<x>, t) \in; P)> \br;
            \c<1> \c<((\vec<x>, t) \nin; P)>
          >>
        >
      >
      で定める。
      仮定から &m<\sb<\op|ord|<ch>><P>> は計算可能であり、\mref|type="thm",ref="primreccomp"|; によって &m<y \mapsto; 1 \dotminus; y> で与えられる関数は原始再帰的なので計算可能でもある。
      したがって、\a|href="107.html#comp"|<定理 10.4> によってこれらの合成である &m<f> も計算可能であることが分かる。
      すなわち、&m<f> を計算するプログラムが存在するので、それを &m<\scr<F>> とする。
      これを用いて、次のプログラムを &m<\scr<H>> とする。
      &mb<
        \array|align="rl"|<
          \c<\rm<A>:> \c<\scr<F> `[ 0, \cdots;, k - 1, k \to; k + 1 \mid; k + 2 `]> \br;
          \c; \c<\tt<dec> \srel; k + 1> \br;
          \c; \c<\tt<end>> \br;
          \c; \c<\tt<inc> \srel; k> \br;
          \c; \c<\tt<backward> \srel; \rm<A>>
        >
      >
      これが &m<h> を計算することを示す。
    >
  >
  \p<
    これで、一般再帰関数も全て計算可能であることが分かる。
  >
  \thm|type="thm",id="genreccomp"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> に対し、&m<f> が一般再帰的ならば、&m<f> は計算可能である。
    >
  >
  \prf<
    \p<
      一般再帰的であるとは、初期関数から合成と原始再帰と最小化の繰り返しで得られる部分関数であった。
      ところで、\a|href="107.html#init"|<命題 10.1> により初期関数は計算可能であり、\a|href="107.html#comp"|<定理 10.4> と\mref|type="thm",ref="rec"|; と\mref|type="thm",ref="min"|; により合成と原始再帰と最小化で計算可能性は保存される。
      したがって、一般再帰的な部分関数は全て計算可能になる。
    >
  >
  \p<
    以上により、計算可能性は一般再帰性より少なくとも同等以上の表現力をもつことが分かった。
    しかし実際には、計算可能関数が全て一般再帰的になることも示せるので、両者の表現力は全く同じである。
    次回からは、これを示すことを目標にする。
  >
  \h1<参考文献>
  \ol<
    \li|id="ectx"|<H. B. Enderton (2011)『Computability Theory』Academic Press>
  >

>