\zml?|version="1.1"|;
\xml?|version="1.0",encoding="UTF-8"|;


\page<
  \name<一般再帰的ならば計算可能>
  \use-math|prefix="11"|;

  \h1<日記 (2026 年 1 月 21 日)>
  \p<
    前回、計算可能性が合成で閉じたことを示した。
    今回は、原始再帰と最小化でも閉じていることを示し、その結果として全ての一般再帰関数が計算可能であることを示す。
  >
  \p<
    まずは、計算可能性が原始再帰で閉じていることを示そう。
  >
  \thm|type="prp",id="rec"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> および部分関数 &m<g: \sp<\bb<N>><k + 2> \dot<\to;> \bb<N>> に対し、これらから原始再帰で得られる部分関数を &m<h: \sp<\bb<N>><k + 1> \dot<\to;> \bb<N>> とする。
      &m<f, g> がともに計算可能ならば、&m<h> も計算可能である。
    >
  >
  \prf<
    \p<
      &m<f, g> を計算するプログラムをそれぞれ &m<\scr<F>, \scr<G>> とし、次のプログラムを &m<\scr<H>> とする。
      &mb<
        \array|align="rl"|<
          \c; \c<\scr<F> `[ 0, \cdots;, k - 1 \to; k + 1 \mid; k + 3 `]> \br;
          \c<\rm<A>:> \c<\tt<dec> \srel; k> \br;
          \c; \c<\tt<end>> \br;
          \c; \c<\scr<G> `[ 0, \cdots;, k - 1, k + 2, k + 1 \to; k + 1 \mid; k + 3 `]> \br;
          \c; \c<\tt<inc> \srel; k + 2> \br;
          \c; \c<\tt<backward> \srel; \rm<A>> \br;
        >
      >
      これが &m<h> を計算することを示したい。
      そのために、メモリが &m<(\sb<x><0>, \cdots;, \sb<x><k - 1>, y, 0, \cdots;)> である状態から &m<\scr<H>> を実行したときの動作を考える。
      以下、自然数 &m<t \srel; (0 \leq; t \leq; y)> に対して、以下の主張を帰納法によって示す。
    >
    \ul<
      \li*<
        &m<h (\vec<x>, t)> が定義されるならば、行 &m<\rm<A>> の命令が &m<t> 回目 (0 から数える) に実行されようとする瞬間が存在し、その直前でのメモリの状態は、
        &mb<
          (\sb<x><0>, \cdots;, \sb<x><k - 1>, y - t, h (\vec<x>, t), t, ?, \cdots;)
        >
        である。
      >
      \li*<
        &m<h (\vec<x>, t)> が定義されないならば、実行は停止しない。
      >
    >
    \p<
      まず &m<t = 0> の場合を示すために、&m<\scr<H>> の動作を初めから追おう。
      &m<h (\vec<x>, 0)> すなわち &m<f (\vec<x>)> が定義されるならば、&m<\scr<F> `[ 0, \cdots;, k - 1 \to; k + 1 \mid; k + 3 `]> が実行されると &m<k + 1> 番目のレジスタの値はその &m<h (\vec<x>, 0)> になり、それ以外の &m<k + 3> 番目より前のレジスタの値は変化しない。
      したがって、この時点でのメモリの状態は、
      &mb<
        (\sb<x><0>, \cdots;, \sb<x><k - 1>, y, f (\vec<x>), 0, 0, \cdots;)
      >
      であり、この状態で次に行 &m<\rm<A>> が実行される。
      &m<h (\vec<x>, 0)> すなわち &m<f (\vec<x>)> が定義されないならば、 &m<\scr<F> `[ 0, \cdots;, k - 1 \to; k + 1 \mid; k + 3 `]> の実行が終了しないので、&m<\scr<H>> の実行全体も停止しない。
      以上で &m<t = 0> の場合の主張は示された。
    >
    \p<
      続いて帰納ステップのために、ある &m<t' \srel; (0 \leq; t' \leq; y - 1)> について &m<t = t'> のときに主張が成り立つと仮定する。
      まずは、&m<h (\vec<x>, t' + 1)> が定義される場合を考える。
      原始再帰の定義により、
      &mb<
        h (\vec<x>, t' + 1) = g (\vec<x>, t',  h (\vec<x>, t'))
      >
      であるから、&m<h (\vec<x>, t')> と &m<g (\vec<x>, t',  h (\vec<x>, t'))> はともに定義されているはずである。
      すなわち、帰納法の仮定により、&m<t'> 回目の行 &m<\rm<A>> の直前では、レジスタが
      &mb<
        (\sb<x><0>, \cdots;, \sb<x><k - 1>, y - t', h (\vec<x>, t'), t', ?, \cdots;)
      >
      となっている。
      ここで、行 &m<\rm<A>> すなわち &m<\tt<dec> \srel; k> が実行されると、&m<y - t' `> 0> であるから、&m<k> 番目のレジスタの値は &m<y - t' - 1> に更新される。
      続いて &m<\scr<G> `[ 0, \cdots;, k - 1, k + 2, k + 1 \to; k + 1 \mid; k + 3 `]> が実行されるから、&m<k + 1> 番目のレジスタの値が &m<g (\vec<x>, t',  h (\vec<x>, t'))> になる。
      次に &m<\tt<inc> \srel; k + 2> が実行されると、&m<k + 2> 番目のレジスタの値は &m<t' + 1> に更新される。
      そして、&m<\tt<backward> \srel; \rm<A>> が実行され、ポインタは行 &m<\rm<A>> に戻る。
      このときのメモリの状態は、
      &mb<
        (\sb<x><0>, \cdots;, \sb<x><k - 1>, y - t' - 1, g (\vec<x>, t',  h (\vec<x>, t')), t' + 1, ?, \cdots;)
      >
      である。
      &m<g (\vec<x>, t',  h (\vec<x>, t')) = h (\vec<x>, t' + 1)> であるから、この場合は主張が示された。
    >
    \p<
      &m<h (\vec<x>, t' + 1)> が定義されない場合は、&m<h (\vec<x>, t')> が定義されていないか、それが定義されても &m<g (\vec<x>, t',  h (\vec<x>, t'))> が定義されないかのどちらかである。
      前者の場合は、帰納法の仮定から &m<\scr<H>> 全体の実行は停止しない。
      後者の場合は、&m<t'> 回目の行 &m<\rm<A>> の実行の後で上の議論と同様に &m<\scr<G> `[ 0, \cdots;, k - 1, k + 2, k + 1 \to; k + 1 \mid; k + 3 `]> の実行に移るが、これが停止しない。
      したがって、どちらの場合でも &m<\scr<H>> 全体の実行は停止しない。
      以上で、帰納ステップも示された。
    >
    \p<
      この主張により、&m<h (\vec<x>, y)> が定義されるなら、&m<y> 回目に行 &m<\rm<A>> が実行されようとする直前でのメモリの状態は、
      &mb<
        (\sb<x><0>, \cdots;, \sb<x><k - 1>, 0, h (\vec<x>, y), y, ?, \cdots;)
      >
      である。
      この状態で行 &m<\rm<A>> すなわち &m<\tt<dec> \srel; k> が実行されると、&m<k> 番目のレジスタの値は &m<0> なのでポインタは直後の行に移り、そこで &m<\scr<H>> の実行は終了し、このときの &m<k + 1> 番目のレジスタの値は &m<h (\vec<x>, y)> である。
      また、&m<h (\vec<x>, y)> が定義されないなら、主張から &m<\scr<H>> の実行は停止しない。
      これで、&m<\scr<H>> が &m<h> を計算することが示された。
    >
  >
  \p<
    さて、これによりまずは原始再帰関数が計算可能であることが分かる。
  >
  \thm|type="thm",id="primreccomp"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> に対し、&m<f> が原始再帰的ならば、&m<f> は計算可能である。
    >
  >
  \prf<
    \p<
      原始再帰的であるとは、初期関数から合成と原始再帰の繰り返しで得られる部分関数であった。
      ところで、\a|href="107.html#init"|<命題 10.1> により初期関数は計算可能であり、\a|href="107.html#comp"|<命題 10.4> と\mref|type="thm",ref="rec"|; により合成と原始再帰で計算可能性は保存される。
      したがって、原始再帰的な部分関数は全て計算可能になる。
    >
  >
  \p<
    続いて、計算可能性が最小化でも閉じていることを示そう。
    なお、これまでの慣習通り、関係が計算可能であるとはその関係の特性関数が計算可能であることをいう。
  >
  \thm|type="prp",id="min"|<
    \p<
      関係 &m<P \subseteq; \sp<\bb<N>><k + 1>> に対し、これから最小化で得られる部分関数を &m<h: \sp<\bb<N>><k> \dot<\to;> \bb<N>> とする。
      &m<P> が計算可能ならば、&m<h> も計算可能である。
    >
  >
  \prf<
    \p<
      全域関数 &m<f: \sp<\bb<N>><k + 1> \to; \bb<N>> を
      &mb<
        \array|align="rcl"|<
          \c<f (\vec<x>, t)> \c<\coloneqq;> \c<1 \dotminus; \sb<\op<ch>><P> (\vec<x>, t)> \br;
          \c; \c<=> \c<\case<
            \c<0> \c<((\vec<x>, t) \in; P)> \br;
            \c<1> \c<((\vec<x>, t) \nin; P)>
          >>
        >
      >
      で定める。
      仮定から &m<\sb<\op|ord|<ch>><P>> は計算可能であり、\mref|type="thm",ref="primreccomp"|; によって &m<y \mapsto; 1 \dotminus; y> で与えられる関数は原始再帰的なので計算可能でもある。
      したがって、\a|href="107.html#comp"|<命題 10.4> によってこれらの合成である &m<f> も計算可能であることが分かる。
      すなわち、&m<f> を計算するプログラムが存在するので、それを &m<\scr<F>> とする。
      これを用いて、次のプログラムを &m<\scr<H>> とする。
      &mb<
        \array|align="rl"|<
          \c<\rm<A>:> \c<\scr<F> `[ 0, \cdots;, k - 1, k \to; k + 1 \mid; k + 2 `]> \br;
          \c<\rm<B>:> \c<\tt<dec> \srel; k + 1> \br;
          \c; \c<\tt<end>> \br;
          \c; \c<\tt<inc> \srel; k> \br;
          \c; \c<\tt<backward> \srel; \rm<A>>
        >
      >
      これが &m<h> を計算することを示すために、メモリが &m<(\sb<x><0>, \cdots;, \sb<x><k - 1>, 0, \cdots;)> である状態から &m<\scr<H>> を実行したときの動作を考える。
      自然数 &m<t> に対し、以下の主張を帰納法によって示す。
    >
    \ul<
      \li*<
         &m<t> 未満の全ての自然数 &m<u> に対して &m<(\vec<x>, u) \nin; P> が成り立つならば、行 &m<\rm<B>> の命令が &m<t> 回目 (0 から数える) に実行されようとする瞬間が存在し、その直前のメモリの状態は、
        &mb<
          (\sb<x><0>, \cdots;, \sb<x><k - 1>, t, f (\vec<x>, t), ?, \cdots;)
        >
        である。
      >
    >
    \p<
       まず &m<t = 0> の場合を示すために、&m<\scr<H>> の動作を初めから追おう。
       初めに &m<\scr<F> `[ 0, \cdots;, k - 1, k \to; k + 1 \mid; k + 2 `]> が実行されるので、&m<k + 1> 番目のレジスタの値が &m<f (\vec<x>, 0)> になる。
       つまり、この時点でのメモリの状態は、
       &mb<
        (\sb<x><0>, \cdots;, \sb<x><k - 1>, 0, f (\vec<x>, 0), ?, \cdots;)
       >
       であり、この状態で次に行 &m<\rm<B>> が実行される。
       これで &m<t = 0> の場合の主張は示された。
    >
    \p<
      続いて帰納ステップのために、ある自然数 &m<t'> について &m<t = t'> のときに主張が成り立つと仮定する。
      また、&m<t' + 1> 未満の全ての自然数 &m<u> に対して &m<(\vec<x>, u) \nin; P> が成り立つとする。
      仮定により、&m<t'> 回目の行 &m<\rm<B>> の直前でのメモリの状態は、
      &mb<  
        (\sb<x><0>, \cdots;, \sb<x><k - 1>, t', f (\vec<x>, t'), ?, \cdots;)
      >
      である。
      ここで、特に &m<(\vec<x>, t') \nin; P> であるから、&m<f (\vec<x>, t') = 1 `> 0> である。
      したがって、行 &m<\rm<B>> すなわち &m<\tt<dec> \srel; k + 1> が実行されると、&m<k + 1> 番目のレジスタの値は &m<0> に減り、次は &m<\tt<inc> \srel; k> が実行される。
      これにより、&m<k> 番目のレジスタの値は &m<t' + 1> に更新され、ポインタは行 &m<\rm<A>> に戻る。
      行 &m<\rm<A>> すなわち &m<\scr<F> `[ 0, \cdots;, k - 1, k \to; k + 1 \mid; k + 2 `]> が実行されると、&m<k + 1> 番目のレジスタの値は &m<f (\vec<x>, t' + 1)> になる。
      このときのメモリの状態は、
      &mb<
        (\sb<x><0>, \cdots;, \sb<x><k - 1>, t' + 1, f (\vec<x>, t' + 1), ?, \cdots;)
      >
      であるから、これで帰納ステップも示された。
    >
    \p<
      さて、今 &m<h (\vec<x>)> が定義されるとする。
      &m<\tilde<t> \coloneqq; h (\vec<x>)> とおけば、それは &m<(\vec<x>, t) \in; P> すなわち &m<f (\vec<x>, t) = 0> を満たす最小の &m<t> である。
      したがって、&m<\tilde<t>> 未満の自然数 &m<u> に対しては &m<(\vec<x>, u) \nin; P> が成り立つ。
      よって主張により、行 &m<\rm<B>> の命令が &m<\tilde<t>> 回目に実行されようとする直前でのメモリの状態は、&m<\tilde<t> = h (\vec<x>)> と &m<f (\vec<x>, \tilde<t>) = 0> であることに注意すれば、
      &mb<
        (\sb<x><0>, \cdots;, \sb<x><k - 1>, h (\vec<x>), 0, ?, \cdots;)
      >
      になっているはずである。
      したがって、この後に &m<\tt<dec> \srel; k + 1> が実行されると、&m<k + 1> 番目のレジスタの値は &m<0> なのでポインタは直後の行に移り、そこで &m<\scr<H>> の実行は終了する。
      このときの &m<k> 番目のレジスタの値は &m<h (\vec<x>)> であるから、この場合は定理が示された。
    >
    \p<
      &m<h (\vec<x>)> が定義されないなら、それはすなわち &m<(\vec<x>, t) \in; P> を満たす &m<t> が存在しないということである。
      そのため主張により、任意の自然数 &m<t> に対して行 B が &m<t> 回目に実行されようとする瞬間が存在することになるが、それは &m<\scr<H>> の実行が停止することはないということである。
      以上により、どちらの場合でも &m<\scr<H>> が &m<h> を計算することが示された。
    >
  >
  \p<
    これで、一般再帰関数も全て計算可能であることが分かる。
  >
  \thm|type="thm",id="genreccomp"|<
    \p<
      部分関数 &m<f: \sp<\bb<N>><k> \dot<\to;> \bb<N>> に対し、&m<f> が一般再帰的ならば、&m<f> は計算可能である。
    >
  >
  \prf<
    \p<
      一般再帰的であるとは、初期関数から合成と原始再帰と最小化の繰り返しで得られる部分関数であった。
      ところで、\a|href="107.html#init"|<命題 10.1> により初期関数は計算可能であり、\a|href="107.html#comp"|<命題 10.4> と\mref|type="thm",ref="rec"|; と\mref|type="thm",ref="min"|; により合成と原始再帰と最小化で計算可能性は保存される。
      したがって、一般再帰的な部分関数は全て計算可能になる。
    >
  >
  \p<
    以上により、計算可能性は一般再帰性より少なくとも同等以上の表現力をもつことが分かった。
    しかし実際には、計算可能関数が全て一般再帰的になることも示せるので、両者の表現力は全く同じである。
    次回からは、これを示すことを目標にする。
  >
  \h1<参考文献>
  \ol<
    \li|id="ectx"|<H. B. Enderton (2011)『Computability Theory』Academic Press>
  >

>